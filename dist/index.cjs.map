{"version":3,"sources":["../src/index.ts","../src/utils.ts","../src/plugins/animations/index.ts","../src/plugins/insert/index.ts","../src/plugins/drop-or-swap/index.ts"],"sourcesContent":["import type {\r\n  DNDPlugin,\r\n  DragAndDrop,\r\n  DragState,\r\n  DragStateProps,\r\n  Node,\r\n  NodeData,\r\n  NodeDragEventData,\r\n  NodeEventData,\r\n  NodePointerEventData,\r\n  NodeRecord,\r\n  NodeTargetData,\r\n  NodesData,\r\n  ParentConfig,\r\n  ParentData,\r\n  ParentEventData,\r\n  ParentTargetData,\r\n  ParentsData,\r\n  PointeroverNodeEvent,\r\n  PointeroverParentEvent,\r\n  SetupNodeData,\r\n  TearDownNodeData,\r\n  BaseDragState,\r\n  SynthDragState,\r\n  SynthDragStateProps,\r\n  ParentRecord,\r\n  EventHandlers,\r\n  NodeFromPoint,\r\n  ParentFromPoint,\r\n  ParentDragEventData,\r\n  DragstartEventData,\r\n} from \"./types\";\r\n\r\nimport {\r\n  pd,\r\n  sp,\r\n  on,\r\n  emit,\r\n  createEmitter,\r\n  eq,\r\n  splitClass,\r\n  eventCoordinates,\r\n} from \"./utils\";\r\n\r\nexport * from \"./types\";\r\nexport { animations } from \"./plugins/animations\";\r\nexport { insert } from \"./plugins/insert\";\r\nexport { dropOrSwap } from \"./plugins/drop-or-swap\";\r\n\r\n/**\r\n * Check to see if code is running in a browser.\r\n */\r\nexport const isBrowser = typeof window !== \"undefined\";\r\n\r\n/**\r\n * Parents or \"lists\" are the containers that nodes or \"draggable items\" can be\r\n * dragged from and into.\r\n *\r\n * @type {WeakMap<HTMLElement, ParentData<unknown>>}\r\n */\r\nexport const parents: ParentsData<any> = new WeakMap<\r\n  HTMLElement,\r\n  ParentData<unknown>\r\n>();\r\n\r\n/**\r\n * Nodes are the draggable items and the direct descendants of the parents.\r\n *\r\n * @type {WeakMap<Node, NodeData<unknown>>}\r\n */\r\nexport const nodes: NodesData<any> = new WeakMap<Node, NodeData<unknown>>();\r\n\r\nfunction isMobilePlatform() {\r\n  if (!isBrowser) return false;\r\n\r\n  if (\"userAgentData\" in navigator) {\r\n    return (navigator.userAgentData as { mobile: boolean }).mobile === true;\r\n  }\r\n\r\n  const ua = navigator.userAgent;\r\n\r\n  const isMobileUA = /android|iphone|ipod/i.test(ua);\r\n\r\n  const isIpad =\r\n    /iPad/.test(ua) ||\r\n    (ua.includes(\"Macintosh\") && navigator.maxTouchPoints > 1);\r\n\r\n  return isMobileUA || isIpad;\r\n}\r\n\r\n/**\r\n * The base drag state.\r\n *\r\n * @type {BaseDragState<unknown>}\r\n */\r\nconst baseDragState = {\r\n  affectedNodes: [],\r\n  coordinates: {\r\n    x: 0,\r\n    y: 0,\r\n  },\r\n  currentTargetValue: undefined,\r\n  on,\r\n  emit,\r\n  originalZIndex: undefined,\r\n  pointerSelection: false,\r\n  preventEnter: false,\r\n  rootUserSelect: undefined,\r\n  nodePointerdown: undefined,\r\n  longPress: false,\r\n  scrolling: false,\r\n  longPressTimeout: undefined,\r\n  remapJustFinished: false,\r\n  selectedNodes: [],\r\n  selectedParent: undefined,\r\n  preventSynthDrag: false,\r\n  pointerDown: undefined,\r\n  lastScrollContainerX: null,\r\n  lastScrollContainerY: null,\r\n  rootScrollWidth: undefined,\r\n  rootScrollHeight: undefined,\r\n  dragItemRect: undefined,\r\n  windowScrollX: undefined,\r\n  windowScrollY: undefined,\r\n  lastScrollDirectionX: undefined,\r\n  lastScrollDirectionY: undefined,\r\n  scrollDebounceTimeout: undefined,\r\n  frameIdX: undefined,\r\n  frameIdY: undefined,\r\n};\r\n\r\n/**\r\n * The state of the drag and drop.\r\n *\r\n * @type {BaseDragState<unknown>}\r\n */\r\nexport let state: BaseDragState<unknown> = baseDragState;\r\n\r\n/**\r\n * Variable to check if the drop has occurred.\r\n */\r\nlet dropped = false;\r\n\r\n/**\r\n * Abort controller for the document.\r\n */\r\nlet documentController: AbortController | undefined;\r\n\r\n/**\r\n * Timeout for the scroll.\r\n */\r\nlet scrollTimeout: ReturnType<typeof setTimeout>;\r\n\r\nexport function resetState() {\r\n  // Clear any existing timeouts to prevent stale references\r\n  if (state.scrollDebounceTimeout) {\r\n    clearTimeout(state.scrollDebounceTimeout);\r\n  }\r\n\r\n  if (state.longPressTimeout) {\r\n    clearTimeout(state.longPressTimeout);\r\n  }\r\n\r\n  // Cancel any animation frames\r\n  if (state.frameIdX !== undefined) {\r\n    cancelAnimationFrame(state.frameIdX);\r\n  }\r\n\r\n  if (state.frameIdY !== undefined) {\r\n    cancelAnimationFrame(state.frameIdY);\r\n  }\r\n\r\n  const baseDragState = {\r\n    affectedNodes: [],\r\n    coordinates: {\r\n      x: 0,\r\n      y: 0,\r\n    },\r\n    on,\r\n    emit,\r\n    currentTargetValue: undefined,\r\n    originalZIndex: undefined,\r\n    pointerId: undefined,\r\n    preventEnter: false,\r\n    remapJustFinished: false,\r\n    selectedNodes: [],\r\n    nodePointerdown: undefined,\r\n    rootUserSelect: undefined,\r\n    preventSynthDrag: false,\r\n    scrolling: false,\r\n    selectedParent: undefined,\r\n    pointerSelection: false,\r\n    synthScrollDirection: undefined,\r\n    draggedNodeDisplay: undefined,\r\n    synthDragScrolling: false,\r\n    longPress: false,\r\n    pointerDown: undefined,\r\n    longPressTimeout: undefined,\r\n    lastScrollContainerX: null,\r\n    lastScrollContainerY: null,\r\n    rootScrollWidth: undefined,\r\n    rootScrollHeight: undefined,\r\n    dragItemRect: undefined,\r\n    windowScrollX: undefined,\r\n    windowScrollY: undefined,\r\n    lastScrollDirectionX: undefined,\r\n    lastScrollDirectionY: undefined,\r\n    scrollDebounceTimeout: undefined,\r\n    frameIdX: undefined,\r\n    frameIdY: undefined,\r\n  };\r\n\r\n  state = { ...baseDragState } as BaseDragState<unknown>;\r\n}\r\n\r\n/**\r\n * @param {DragStateProps} dragStateProps - Attributes to update state with.\r\n *\r\n * @mutation - Updates state with node values.\r\n *\r\n * @returns void\r\n */\r\nexport function setDragState<T>(\r\n  dragStateProps: (SynthDragStateProps & DragStateProps<T>) | DragStateProps<T>\r\n): DragState<T> | SynthDragState<T> {\r\n  Object.assign(state, dragStateProps);\r\n\r\n  dragStateProps.initialParent.data.emit(\"dragStarted\", state);\r\n\r\n  dropped = false;\r\n\r\n  state.emit(\"dragStarted\", state);\r\n\r\n  return state as DragState<T> | SynthDragState<T>;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nfunction handleRootPointerdown() {\r\n  if (state.activeState) setActive(state.activeState.parent, undefined, state);\r\n\r\n  if (state.selectedState)\r\n    deselect(state.selectedState.nodes, state.selectedState.parent, state);\r\n\r\n  state.selectedState = state.activeState = undefined;\r\n}\r\n\r\nfunction handleRootPointerup() {\r\n  if (state.pointerDown) state.pointerDown.node.el.draggable = true;\r\n\r\n  state.pointerDown = undefined;\r\n\r\n  if (!isSynthDragState(state)) return;\r\n\r\n  const config = state.currentParent.data.config;\r\n\r\n  if (isSynthDragState(state)) config.handleEnd(state);\r\n}\r\n\r\n/**\r\n * Handles the keydown event on the root element.\r\n *\r\n * @param {KeyboardEvent} e - The keyboard event.\r\n */\r\nfunction handleRootKeydown(e: KeyboardEvent) {\r\n  if (e.key === \"Escape\") {\r\n    if (state.selectedState)\r\n      deselect(state.selectedState.nodes, state.selectedState.parent, state);\r\n\r\n    if (state.activeState)\r\n      setActive(state.activeState.parent, undefined, state);\r\n\r\n    state.selectedState = state.activeState = undefined;\r\n  }\r\n}\r\n\r\nfunction handleRootDrop(_e: DragEvent) {\r\n  if (!isDragState(state)) return;\r\n\r\n  dropped = true;\r\n\r\n  const handleEnd = state.initialParent.data.config.handleEnd;\r\n\r\n  handleEnd(state);\r\n}\r\n\r\nfunction handleRootDragover(e: DragEvent) {\r\n  if (!isDragState(state)) return;\r\n\r\n  pd(e);\r\n\r\n  const { x, y } = eventCoordinates(e);\r\n\r\n  if (isDragState(state)) {\r\n    handleSynthScroll({ x, y }, e, state);\r\n  }\r\n}\r\n\r\nfunction handleRootPointermove(e: PointerEvent) {\r\n  if (!state.pointerDown || !state.pointerDown.validated) return;\r\n\r\n  const config = state.pointerDown.parent.data.config;\r\n\r\n  if (e.pointerType === \"mouse\" && !isMobilePlatform()) {\r\n    return;\r\n  }\r\n\r\n  if (!isSynthDragState(state)) {\r\n    pd(e);\r\n\r\n    if (config.longPress && !state.longPress) {\r\n      clearTimeout(state.longPressTimeout);\r\n\r\n      state.longPress = false;\r\n\r\n      return;\r\n    }\r\n\r\n    const nodes = config.draggedNodes(state.pointerDown);\r\n\r\n    config.dragstartClasses(state.pointerDown.node, nodes, config, true);\r\n\r\n    const rect = state.pointerDown.node.el.getBoundingClientRect();\r\n\r\n    const synthDragState = initSynthDrag(\r\n      state.pointerDown.node,\r\n      state.pointerDown.parent,\r\n      e,\r\n      state,\r\n      nodes,\r\n      rect\r\n    );\r\n\r\n    synthMove(e, synthDragState, true);\r\n  } else if (isSynthDragState(state)) {\r\n    synthMove(e, state);\r\n  }\r\n}\r\n\r\n/**\r\n * Initializes the drag and drop functionality for a given parent.\r\n *\r\n * @param {DragAndDrop} dragAndDrop - The drag and drop configuration.\r\n *\r\n * @returns void\r\n */\r\nexport function dragAndDrop<T>({\r\n  parent,\r\n  getValues,\r\n  setValues,\r\n  config = {},\r\n}: DragAndDrop<T>): void {\r\n  if (!isBrowser) return;\r\n\r\n  if (!documentController) {\r\n    documentController = addEvents(document, {\r\n      dragover: handleRootDragover,\r\n      pointerdown: handleRootPointerdown,\r\n      pointerup: handleRootPointerup,\r\n      keydown: handleRootKeydown,\r\n      drop: handleRootDrop,\r\n      pointermove: handleRootPointermove,\r\n      pointercancel: nodeEventData(config.handlePointercancel),\r\n      touchmove: (e: TouchEvent) => {\r\n        if (isDragState(state) && e.cancelable) pd(e);\r\n      },\r\n      contextmenu: (e: Event) => {\r\n        if (isSynthDragState(state)) pd(e);\r\n      },\r\n    });\r\n  }\r\n\r\n  tearDown(parent);\r\n\r\n  const [emit, on] = createEmitter();\r\n\r\n  const parentData: ParentData<T> = {\r\n    getValues,\r\n    setValues,\r\n    config: {\r\n      dragDropEffect: config.dragDropEffect ?? \"move\",\r\n      dragEffectAllowed: config.dragEffectAllowed ?? \"move\",\r\n      draggedNodes,\r\n      dragstartClasses,\r\n      handleNodeKeydown,\r\n      handleDragstart,\r\n      handleNodeDragover,\r\n      handleParentDragover,\r\n      handleNodeDrop,\r\n      handleNodeFocus,\r\n      handleNodeBlur,\r\n      handlePointercancel,\r\n      handleEnd,\r\n      handleDragend,\r\n      handleParentFocus,\r\n      handleNodePointerup,\r\n      handleNodePointerover,\r\n      handleParentPointerover,\r\n      handleParentScroll,\r\n      handleNodePointerdown,\r\n      handleNodeDragenter,\r\n      handleNodeDragleave,\r\n      handleParentDrop,\r\n      multiDrag: config.multiDrag ?? false,\r\n      nativeDrag: config.nativeDrag ?? true,\r\n      performSort,\r\n      performTransfer,\r\n      root: config.root ?? document,\r\n      setupNode,\r\n      setupNodeRemap,\r\n      reapplyDragClasses,\r\n      tearDownNode,\r\n      tearDownNodeRemap,\r\n      remapFinished,\r\n      threshold: {\r\n        horizontal: 0,\r\n        vertical: 0,\r\n      },\r\n      ...config,\r\n    },\r\n    enabledNodes: [],\r\n    abortControllers: {},\r\n    privateClasses: [],\r\n    on,\r\n    emit,\r\n  };\r\n\r\n  const nodesObserver = new MutationObserver(nodesMutated);\r\n\r\n  nodesObserver.observe(parent, { childList: true });\r\n\r\n  parents.set(parent, parentData);\r\n\r\n  config.plugins?.forEach((plugin) => {\r\n    plugin(parent)?.tearDown?.();\r\n  });\r\n\r\n  config.plugins?.forEach((plugin) => {\r\n    plugin(parent)?.tearDown?.();\r\n  });\r\n\r\n  config.plugins?.forEach((plugin: DNDPlugin) => {\r\n    plugin(parent)?.setup?.();\r\n  });\r\n\r\n  setup(parent, parentData);\r\n\r\n  remapNodes(parent, true);\r\n}\r\n\r\nexport function dragStateProps<T>(\r\n  node: NodeRecord<T>,\r\n  parent: ParentRecord<T>,\r\n  e: PointerEvent | DragEvent,\r\n  draggedNodes: Array<NodeRecord<T>>,\r\n  offsetX?: number,\r\n  offsetY?: number\r\n): DragStateProps<T> {\r\n  const { x, y } = eventCoordinates(e);\r\n\r\n  const rect = node.el.getBoundingClientRect();\r\n\r\n  return {\r\n    affectedNodes: [],\r\n    ascendingDirection: false,\r\n    clonedDraggedEls: [],\r\n    coordinates: {\r\n      x,\r\n      y,\r\n    },\r\n    draggedNode: {\r\n      el: node.el,\r\n      data: node.data,\r\n    },\r\n    draggedNodes,\r\n    incomingDirection: undefined,\r\n    initialIndex: node.data.index,\r\n    initialParent: {\r\n      el: parent.el,\r\n      data: parent.data,\r\n    },\r\n    currentParent: {\r\n      el: parent.el,\r\n      data: parent.data,\r\n    },\r\n    longPress: parent.data.config.longPress ?? false,\r\n    longPressTimeout: undefined,\r\n    currentTargetValue: node.data.value,\r\n    scrollEls: [],\r\n    startLeft: offsetX ? offsetX : x - (rect?.left ?? 0),\r\n    startTop: offsetY ? offsetY : y - (rect?.top ?? 0),\r\n    targetIndex: node.data.index,\r\n    transferred: false,\r\n  };\r\n}\r\n\r\n/**\r\n * Perform the sort of the nodes.\r\n *\r\n * @param {ParentRecord<T>} parent - The parent record.\r\n * @param {Array<NodeRecord<T>>} draggedNodes - The dragged nodes.\r\n * @param {Array<NodeRecord<T>>} targetNodes - The target nodes.\r\n *\r\n * @returns void\r\n */\r\nexport function performSort<T>({\r\n  parent,\r\n  draggedNodes,\r\n  targetNodes,\r\n}: {\r\n  parent: ParentRecord<T>;\r\n  draggedNodes: Array<NodeRecord<T>>;\r\n  targetNodes: Array<NodeRecord<T>>;\r\n}) {\r\n  remapNodes(parent.el);\r\n\r\n  const draggedValues = draggedNodes.map((x) => x.data.value);\r\n\r\n  const targetParentValues = parentValues(parent.el, parent.data);\r\n\r\n  const originalIndex = draggedNodes[0].data.index;\r\n\r\n  const enabledNodes = [...parent.data.enabledNodes];\r\n\r\n  const newParentValues = [\r\n    ...targetParentValues.filter((x) => !draggedValues.some((y) => eq(x, y))),\r\n  ];\r\n  newParentValues.splice(targetNodes[0].data.index, 0, ...draggedValues);\r\n\r\n  if (\"draggedNode\" in state)\r\n    state.currentTargetValue = targetNodes[0].data.value;\r\n\r\n  setParentValues(parent.el, parent.data, [...newParentValues]);\r\n\r\n  if (parent.data.config.onSort) {\r\n    parent.data.config.onSort({\r\n      parent: {\r\n        el: parent.el,\r\n        data: parent.data,\r\n      } as ParentRecord<unknown>,\r\n      previousValues: [...targetParentValues],\r\n      previousNodes: [...enabledNodes],\r\n      nodes: [...parent.data.enabledNodes],\r\n      values: [...newParentValues],\r\n      draggedNodes: draggedNodes,\r\n      previousPosition: originalIndex,\r\n      position: targetNodes[0].data.index,\r\n      targetNodes,\r\n      state,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * This function sets the active node as well as removing any classes or\r\n * attribute set.\r\n *\r\n * @param {ParentEventData} data - The parent event data.\r\n * @param {NodeRecord} newActiveNode - The new active node.\r\n * @param {BaseDragState} state - The current drag state.\r\n */\r\nfunction setActive<T>(\r\n  parent: ParentRecord<T>,\r\n  newActiveNode: NodeRecord<T> | undefined,\r\n  state: BaseDragState<T>\r\n) {\r\n  if (!newActiveNode) {\r\n    state.activeState = undefined;\r\n\r\n    return;\r\n  }\r\n\r\n  state.activeState = {\r\n    node: newActiveNode,\r\n    parent,\r\n  };\r\n}\r\n\r\n/**\r\n * This function deselects the nodes. This will clean the prior selected state\r\n * as well as removing any classes or attributes set.\r\n *\r\n * @param {Array<NodeRecord<T>>} nodes - The nodes to deselect.\r\n * @param {ParentRecord<T>} parent - The parent record.\r\n * @param {BaseDragState<T>} state - The current drag state.\r\n */\r\nfunction deselect<T>(\r\n  nodes: Array<NodeRecord<T>>,\r\n  parent: ParentRecord<T>,\r\n  state: BaseDragState<T>\r\n) {\r\n  const selectedClass = parent.data.config.selectedClass;\r\n\r\n  if (!state.selectedState) return;\r\n\r\n  const iterativeNodes = Array.from(nodes);\r\n\r\n  removeClass(\r\n    nodes.map((x) => x.el),\r\n    selectedClass\r\n  );\r\n\r\n  for (const node of iterativeNodes) {\r\n    node.el.setAttribute(\"aria-selected\", \"false\");\r\n\r\n    const index = state.selectedState.nodes.findIndex((x) => x.el === node.el);\r\n\r\n    if (index === -1) continue;\r\n\r\n    state.selectedState.nodes.splice(index, 1);\r\n  }\r\n}\r\n\r\n/**\r\n * This function sets the selected nodes. This will clean the prior selected\r\n * state as well as removing any classes or attributes set.\r\n *\r\n * @param {ParentRecord<T>} parent - The parent record.\r\n * @param {Array<NodeRecord<T>>} selectedNodes - The nodes to select.\r\n * @param {NodeRecord<T> | undefined} newActiveNode - The new active node.\r\n * @param {BaseDragState<T>} state - The current drag state.\r\n * @param {boolean} pointerdown - Whether the pointerdown event was triggered.\r\n */\r\nfunction setSelected<T>(\r\n  parent: ParentRecord<T>,\r\n  selectedNodes: Array<NodeRecord<T>>,\r\n  newActiveNode: NodeRecord<T> | undefined,\r\n  state: BaseDragState<T>,\r\n  pointerdown = false\r\n) {\r\n  state.pointerSelection = pointerdown;\r\n\r\n  for (const node of selectedNodes) {\r\n    node.el.setAttribute(\"aria-selected\", \"true\");\r\n\r\n    addNodeClass([node.el], parent.data.config.selectedClass, true);\r\n  }\r\n\r\n  state.selectedState = {\r\n    nodes: selectedNodes,\r\n    parent,\r\n  };\r\n\r\n  setActive(parent, newActiveNode, state);\r\n}\r\n\r\n/**\r\n * Handle the parent focus event.\r\n *\r\n * @param {ParentEventData<T>} data - The parent event data.\r\n * @param {BaseDragState<T> | DragState<T> | SynthDragState<T>} state - The drag state.\r\n *\r\n * @returns void\r\n */\r\nexport function handleParentFocus<T>(\r\n  data: ParentEventData<T>,\r\n  state: BaseDragState<T> | DragState<T> | SynthDragState<T>\r\n) {\r\n  const firstEnabledNode = data.targetData.parent.data.enabledNodes[0];\r\n\r\n  if (!firstEnabledNode) return;\r\n\r\n  if (\r\n    state.selectedState &&\r\n    state.selectedState.parent.el !== data.targetData.parent.el\r\n  ) {\r\n    setActive(data.targetData.parent, firstEnabledNode, state);\r\n  } else if (!state.selectedState) {\r\n    setActive(data.targetData.parent, firstEnabledNode, state);\r\n  }\r\n}\r\n\r\n/**\r\n * Perform the transfer of the nodes.\r\n *\r\n * @param data - The transfer data.\r\n * @param state - The drag state.\r\n *\r\n * @returns void\r\n */\r\nexport function performTransfer<T>({\r\n  currentParent,\r\n  targetParent,\r\n  initialParent,\r\n  draggedNodes,\r\n  initialIndex,\r\n  targetNodes,\r\n  state,\r\n}: {\r\n  currentParent: ParentRecord<T>;\r\n  targetParent: ParentRecord<T>;\r\n  initialParent: ParentRecord<T>;\r\n  draggedNodes: Array<NodeRecord<T>>;\r\n  initialIndex: number;\r\n  state: BaseDragState<T> | DragState<T> | SynthDragState<T>;\r\n  targetNodes: Array<NodeRecord<T>>;\r\n}) {\r\n  remapNodes(initialParent.el);\r\n\r\n  const draggedValues = draggedNodes.map((x) => x.data.value);\r\n\r\n  const currentParentValues = [\r\n    ...parentValues(currentParent.el, currentParent.data).filter(\r\n      (x) => !draggedValues.some((y) => eq(x, y))\r\n    ),\r\n  ];\r\n\r\n  const targetParentValues = parentValues(targetParent.el, targetParent.data);\r\n\r\n  const reset =\r\n    initialParent.el === targetParent.el &&\r\n    targetParent.data.config.sortable === false;\r\n\r\n  let targetIndex: number;\r\n\r\n  if (targetNodes.length) {\r\n    if (reset) {\r\n      targetIndex = initialIndex;\r\n    } else if (targetParent.data.config.sortable === false) {\r\n      targetIndex = targetParent.data.enabledNodes.length;\r\n    } else {\r\n      targetIndex = targetNodes[0].data.index;\r\n    }\r\n\r\n    targetParentValues.splice(targetIndex, 0, ...draggedValues);\r\n  } else {\r\n    targetIndex = reset ? initialIndex : targetParent.data.enabledNodes.length;\r\n\r\n    targetParentValues.splice(targetIndex, 0, ...draggedValues);\r\n  }\r\n\r\n  setParentValues(currentParent.el, currentParent.data, currentParentValues);\r\n\r\n  setParentValues(targetParent.el, targetParent.data, targetParentValues);\r\n\r\n  if (targetParent.data.config.onTransfer) {\r\n    targetParent.data.config.onTransfer({\r\n      sourceParent: currentParent,\r\n      targetParent,\r\n      initialParent,\r\n      draggedNodes,\r\n      targetIndex,\r\n      state,\r\n      targetNodes,\r\n    });\r\n  }\r\n\r\n  if (currentParent.data.config.onTransfer) {\r\n    currentParent.data.config.onTransfer({\r\n      sourceParent: currentParent,\r\n      targetParent,\r\n      initialParent,\r\n      draggedNodes,\r\n      targetIndex,\r\n      state,\r\n      targetNodes: targetNodes ? targetNodes : [],\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Get the values of the parent.\r\n *\r\n * @param parent - The parent element.\r\n * @param parentData - The parent data.\r\n *\r\n * @returns The values of the parent.\r\n */\r\nexport function parentValues<T>(\r\n  parent: HTMLElement,\r\n  parentData: ParentData<T>\r\n): Array<T> {\r\n  return [...parentData.getValues(parent)];\r\n}\r\n\r\n/**\r\n * Set the values of the parent.\r\n *\r\n * @param parent - The parent element.\r\n * @param parentData - The parent data.\r\n * @param values - The values to set.\r\n *\r\n * @returns void\r\n */\r\nexport function setParentValues<T>(\r\n  parent: HTMLElement,\r\n  parentData: ParentData<T>,\r\n  values: Array<any>\r\n): void {\r\n  parentData.setValues(values, parent);\r\n}\r\n\r\n/**\r\n * Get the values of the dragged nodes.\r\n *\r\n * @param state - The drag state.\r\n *\r\n * @returns The values of the dragged nodes.\r\n */\r\nexport function dragValues<T>(state: DragState<T>): Array<T> {\r\n  return [...state.draggedNodes.map((x) => x.data.value)];\r\n}\r\n\r\n/**\r\n * Utility function to update parent config.\r\n *\r\n * @param parent - The parent element.\r\n * @param config - The config to update.\r\n *\r\n * @returns void\r\n */\r\nexport function updateConfig<T>(\r\n  parent: HTMLElement,\r\n  config: Partial<ParentConfig<T>>\r\n) {\r\n  const parentData = parents.get(parent);\r\n\r\n  if (!parentData) return;\r\n\r\n  parents.set(parent, {\r\n    ...parentData,\r\n    config: { ...parentData.config, ...config },\r\n  });\r\n\r\n  dragAndDrop({\r\n    parent,\r\n    getValues: parentData.getValues,\r\n    setValues: parentData.setValues,\r\n    config,\r\n  });\r\n}\r\n\r\n/**\r\n * Handle the parent drop event.\r\n *\r\n * @param data - The parent event data.\r\n * @param state - The drag state.\r\n *\r\n * @returns void\r\n */\r\nexport function handleParentDrop<T>(\r\n  data: ParentEventData<T>,\r\n  state: DragState<T>\r\n) {\r\n  sp(data.e);\r\n\r\n  dropped = true;\r\n\r\n  const handleEnd = state.initialParent.data.config.handleEnd;\r\n\r\n  handleEnd(state);\r\n}\r\n\r\n/**\r\n * Tear down the parent.\r\n *\r\n * @param parent - The parent element.\r\n *\r\n * @returns void\r\n */\r\nexport function tearDown(parent: HTMLElement) {\r\n  const parentData = parents.get(parent);\r\n\r\n  if (!parentData) return;\r\n\r\n  if (parentData.abortControllers.mainParent)\r\n    parentData.abortControllers.mainParent.abort();\r\n}\r\n\r\n/**\r\n * Check if the state is a drag state.\r\n *\r\n * @param state - The state to check.\r\n *\r\n * @returns Whether the state is a drag state.\r\n */\r\nexport function isDragState<T>(\r\n  state: BaseDragState<T>\r\n): state is DragState<T> | SynthDragState<T> {\r\n  return \"draggedNode\" in state && !!state.draggedNode;\r\n}\r\n\r\n/**\r\n * Check if the state is a synth drag state.\r\n *\r\n * @param state - The state to check.\r\n *\r\n * @returns Whether the state is a synth drag state.\r\n */\r\nexport function isSynthDragState<T>(\r\n  state: BaseDragState<T>\r\n): state is SynthDragState<T> {\r\n  return \"synthDragging\" in state && !!state.synthDragging;\r\n}\r\n\r\n/**\r\n * Setup the parent.\r\n *\r\n * @param parent - The parent element.\r\n * @param parentData - The parent data.\r\n *\r\n * @returns void\r\n */\r\nfunction setup<T>(parent: HTMLElement, parentData: ParentData<T>): void {\r\n  parentData.abortControllers.mainParent = addEvents(parent, {\r\n    dragover: parentEventData(parentData.config.handleParentDragover),\r\n    handleParentPointerover: parentData.config.handleParentPointerover,\r\n    scroll: parentEventData(parentData.config.handleParentScroll),\r\n    drop: parentEventData(parentData.config.handleParentDrop),\r\n    hasNestedParent: (e: CustomEvent) => {\r\n      const parent = parents.get(e.target as HTMLElement);\r\n\r\n      if (!parent) return;\r\n\r\n      parent.nestedParent = e.detail.parent;\r\n    },\r\n    focus: parentEventData(parentData.config.handleParentFocus),\r\n  });\r\n\r\n  if (\r\n    parentData.config.externalDragHandle &&\r\n    parentData.config.externalDragHandle.el &&\r\n    parentData.config.externalDragHandle.callback\r\n  ) {\r\n    parentData.abortControllers.externalDragHandle = addEvents(\r\n      parentData.config.externalDragHandle.el,\r\n      {\r\n        pointerdown: (_e: PointerEvent) => {\r\n          if (\r\n            !parentData.config.externalDragHandle ||\r\n            !parentData.config.externalDragHandle.callback\r\n          )\r\n            return;\r\n\r\n          const draggableItem = parentData.config.externalDragHandle.callback();\r\n\r\n          if (!isNode(draggableItem)) {\r\n            console.warn(\r\n              \"No draggable item found from external drag handle callback\"\r\n            );\r\n\r\n            return;\r\n          }\r\n\r\n          const nodeData = nodes.get(draggableItem);\r\n\r\n          if (!nodeData) return;\r\n\r\n          const parentNode = draggableItem.parentNode;\r\n\r\n          if (!(parentNode instanceof HTMLElement)) return;\r\n\r\n          const parent = parents.get(parentNode);\r\n\r\n          if (!parent) return;\r\n\r\n          state.pointerDown = {\r\n            parent: {\r\n              el: parentNode,\r\n              data: parent,\r\n            },\r\n            node: {\r\n              el: draggableItem,\r\n              data: nodeData,\r\n            },\r\n            validated: true,\r\n          };\r\n\r\n          draggableItem.draggable = true;\r\n        },\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Set the attributes of the element.\r\n *\r\n * @param el - The element.\r\n * @param attrs - The attributes to set.\r\n *\r\n * @returns void\r\n */\r\nexport function setAttrs(el: HTMLElement, attrs: Record<string, string>) {\r\n  for (const key in attrs) el.setAttribute(key, attrs[key]);\r\n}\r\n\r\n/**\r\n * Setup the node.\r\n *\r\n * @param data - The setup node data.\r\n *\r\n * @returns void\r\n */\r\nexport function setupNode<T>(data: SetupNodeData<T>) {\r\n  const config = data.parent.data.config;\r\n\r\n  data.node.data.abortControllers.mainNode = addEvents(data.node.el, {\r\n    keydown: nodeEventData(config.handleNodeKeydown),\r\n    dragstart: nodeEventData(config.handleDragstart),\r\n    dragover: nodeEventData(config.handleNodeDragover),\r\n    dragenter: nodeEventData(config.handleNodeDragenter),\r\n    dragleave: nodeEventData(config.handleNodeDragleave),\r\n    dragend: nodeEventData(config.handleDragend),\r\n    drop: nodeEventData(config.handleNodeDrop),\r\n    focus: nodeEventData(config.handleNodeFocus),\r\n    blur: nodeEventData(config.handleNodeBlur),\r\n    pointerup: nodeEventData(config.handleNodePointerup),\r\n    pointercancel: nodeEventData(config.handlePointercancel),\r\n    pointerdown: nodeEventData(config.handleNodePointerdown),\r\n    handleNodePointerover: config.handleNodePointerover,\r\n    touchmove: (e: TouchEvent) => {\r\n      if (isDragState(state) && e.cancelable) pd(e);\r\n    },\r\n    contextmenu: (e: Event) => {\r\n      if (isSynthDragState(state)) pd(e);\r\n    },\r\n  });\r\n\r\n  data.node.el.draggable = true;\r\n\r\n  config.reapplyDragClasses(data.node.el, data.parent.data);\r\n\r\n  data.parent.data.config.plugins?.forEach((plugin: DNDPlugin) => {\r\n    plugin(data.parent.el)?.setupNode?.(data);\r\n  });\r\n}\r\n\r\n/**\r\n * Setup the node remap.\r\n *\r\n * @param data - The setup node data.\r\n *\r\n * @returns void\r\n */\r\nexport function setupNodeRemap<T>(data: SetupNodeData<T>) {\r\n  nodes.set(data.node.el, data.node.data);\r\n\r\n  data.parent.data.config.plugins?.forEach((plugin: DNDPlugin) => {\r\n    plugin(data.parent.el)?.setupNodeRemap?.(data);\r\n  });\r\n}\r\n\r\n/**\r\n * Reapply the drag classes to the node.\r\n *\r\n * @param node - The node.\r\n * @param parentData - The parent data.\r\n *\r\n * @returns void\r\n */\r\nfunction reapplyDragClasses<T>(node: Node, parentData: ParentData<T>) {\r\n  if (!isDragState(state)) return;\r\n\r\n  const dropZoneClass = isSynthDragState(state)\r\n    ? parentData.config.synthDropZoneClass\r\n    : parentData.config.dropZoneClass;\r\n\r\n  if (state.draggedNode.el !== node) return;\r\n\r\n  addNodeClass([node], dropZoneClass, true);\r\n}\r\n\r\n/**\r\n * Tear down the node remap.\r\n *\r\n * @param data - The tear down node data.\r\n *\r\n * @returns void\r\n */\r\nexport function tearDownNodeRemap<T>(data: TearDownNodeData<T>) {\r\n  data.parent.data.config.plugins?.forEach((plugin: DNDPlugin) => {\r\n    plugin(data.parent.el)?.tearDownNodeRemap?.(data);\r\n  });\r\n}\r\n\r\n/**\r\n * Tear down the node.\r\n *\r\n * @param data - The tear down node data.\r\n *\r\n * @returns void\r\n */\r\nexport function tearDownNode<T>(data: TearDownNodeData<T>) {\r\n  data.parent.data.config.plugins?.forEach((plugin: DNDPlugin) => {\r\n    plugin(data.parent.el)?.tearDownNode?.(data);\r\n  });\r\n\r\n  data.node.el.draggable = false;\r\n\r\n  if (data.node.data?.abortControllers?.mainNode)\r\n    data.node.data?.abortControllers?.mainNode.abort();\r\n}\r\n\r\n/**\r\n * Called when the nodes of a given parent element are mutated.\r\n *\r\n * @param mutationList - The list of mutations.\r\n *\r\n * @returns void\r\n *\r\n * @internal\r\n */\r\nfunction nodesMutated(mutationList: MutationRecord[]) {\r\n  // TODO: This could be better, but using it as a way to ignore comments and text\r\n  if (\r\n    mutationList.length === 1 &&\r\n    mutationList[0].addedNodes.length === 1 &&\r\n    !(mutationList[0].addedNodes[0] instanceof HTMLElement)\r\n  )\r\n    return;\r\n\r\n  const parentEl = mutationList[0].target;\r\n\r\n  if (!(parentEl instanceof HTMLElement)) return;\r\n\r\n  const parentData = parents.get(parentEl);\r\n\r\n  if (!parentData) return;\r\n\r\n  remapNodes(parentEl);\r\n}\r\n\r\n/**\r\n * Remaps the data of the parent element's children.\r\n *\r\n * @param parent - The parent element.\r\n *\r\n * @returns void\r\n *\r\n * @internal\r\n */\r\nexport function remapNodes<T>(parent: HTMLElement, force?: boolean) {\r\n  const parentData = parents.get(parent);\r\n\r\n  if (!parentData) return;\r\n\r\n  parentData.privateClasses = Array.from(parent.classList);\r\n\r\n  const enabledNodes: Array<Node> = [];\r\n\r\n  const config = parentData.config;\r\n\r\n  for (let x = 0; x < parent.children.length; x++) {\r\n    const node = parent.children[x];\r\n\r\n    if (!isNode(node) || node.id === \"dnd-dragged-node-clone\") continue;\r\n\r\n    const nodeData = nodes.get(node);\r\n\r\n    // Only tear down the node if we have explicitly called dragAndDrop\r\n    if (force || !nodeData)\r\n      config.tearDownNode({\r\n        parent: {\r\n          el: parent,\r\n          data: parentData,\r\n        },\r\n        node: {\r\n          el: node,\r\n          data: nodeData,\r\n        },\r\n      });\r\n\r\n    if (config.disabled) continue;\r\n\r\n    if (!config.draggable || (config.draggable && config.draggable(node))) {\r\n      enabledNodes.push(node);\r\n    }\r\n  }\r\n\r\n  if (\r\n    enabledNodes.length !== parentData.getValues(parent).length &&\r\n    !config.disabled\r\n  ) {\r\n    console.warn(\r\n      \"The number of draggable items defined in the parent element does not match the number of values. This may cause unexpected behavior.\"\r\n    );\r\n\r\n    return;\r\n  }\r\n\r\n  const values = parentData.getValues(parent);\r\n\r\n  const enabledNodeRecords: Array<NodeRecord<T>> = [];\r\n\r\n  for (let x = 0; x < enabledNodes.length; x++) {\r\n    const node = enabledNodes[x];\r\n\r\n    const prevNodeData = nodes.get(node);\r\n\r\n    if (config.draggableValue && !config.draggableValue(values[x])) continue;\r\n\r\n    const nodeData = Object.assign(\r\n      prevNodeData ?? {\r\n        privateClasses: [],\r\n        abortControllers: {},\r\n      },\r\n      {\r\n        value: values[x],\r\n        index: x,\r\n      }\r\n    );\r\n\r\n    if (\r\n      !isDragState(state) &&\r\n      state.activeState &&\r\n      eq(state.activeState.node.data.value, nodeData.value)\r\n    ) {\r\n      setActive(\r\n        {\r\n          data: parentData,\r\n          el: parent,\r\n        },\r\n        {\r\n          el: node,\r\n          data: nodeData,\r\n        },\r\n        state\r\n      );\r\n    }\r\n\r\n    if (\r\n      isDragState(state) &&\r\n      eq(state.draggedNode.data.value, nodeData.value)\r\n    ) {\r\n      state.draggedNode.data = nodeData;\r\n\r\n      state.draggedNode.el = node;\r\n\r\n      const draggedNode = state.draggedNodes.find(\r\n        (x) => x.data.value === nodeData.value\r\n      );\r\n\r\n      if (draggedNode) draggedNode.el = node;\r\n    }\r\n\r\n    enabledNodeRecords.push({\r\n      el: node,\r\n      data: nodeData,\r\n    });\r\n\r\n    if (force || !prevNodeData)\r\n      config.setupNode({\r\n        parent: {\r\n          el: parent,\r\n          data: parentData,\r\n        },\r\n        node: {\r\n          el: node,\r\n          data: nodeData,\r\n        },\r\n      });\r\n\r\n    setupNodeRemap({\r\n      parent: {\r\n        el: parent,\r\n        data: parentData,\r\n      },\r\n      node: {\r\n        el: node,\r\n        data: nodeData,\r\n      },\r\n    });\r\n  }\r\n\r\n  parents.set(parent, { ...parentData, enabledNodes: enabledNodeRecords });\r\n\r\n  config.remapFinished(parentData);\r\n\r\n  parentData.config.plugins?.forEach((plugin: DNDPlugin) => {\r\n    plugin(parent)?.remapFinished?.();\r\n  });\r\n}\r\n\r\n/**\r\n * Set the remap just finished flag.\r\n *\r\n * @returns void\r\n */\r\nexport function remapFinished() {\r\n  state.remapJustFinished = true;\r\n\r\n  if (\"draggedNode\" in state) state.affectedNodes = [];\r\n}\r\n\r\n/**\r\n * Validate the drag start.\r\n *\r\n * @param data - The node event data.\r\n *\r\n * @returns Whether the drag start is valid.\r\n */\r\nexport function validateDragstart(data: NodeEventData<any>): boolean {\r\n  return !!data.targetData.parent.data.config.nativeDrag;\r\n}\r\n\r\n/**\r\n * Get the dragged nodes.\r\n *\r\n * @param pointerDown - The pointer down data.\r\n *\r\n * @returns The dragged nodes.\r\n */\r\nfunction draggedNodes<T>(pointerDown: {\r\n  parent: ParentRecord<T>;\r\n  node: NodeRecord<T>;\r\n}): Array<NodeRecord<T>> {\r\n  if (!pointerDown.parent.data.config.multiDrag) {\r\n    return [pointerDown.node];\r\n  } else if (state.selectedState) {\r\n    return [\r\n      pointerDown.node,\r\n      ...(state.selectedState?.nodes.filter(\r\n        (x) => x.el !== pointerDown.node.el\r\n      ) as Array<NodeRecord<T>>),\r\n    ];\r\n  }\r\n\r\n  return [];\r\n}\r\n\r\n/**\r\n * Handle the parent scroll.\r\n *\r\n * @param data - The parent event data.\r\n *\r\n * @returns void\r\n */\r\nfunction handleParentScroll<T>(_data: ParentEventData<T>) {\r\n  if (!isDragState(state)) return;\r\n\r\n  state.emit(\"scrollStarted\", state);\r\n\r\n  if (isSynthDragState(state)) return;\r\n\r\n  state.preventEnter = true;\r\n\r\n  if (scrollTimeout) clearTimeout(scrollTimeout);\r\n\r\n  scrollTimeout = setTimeout(() => {\r\n    state.preventEnter = false;\r\n\r\n    state.emit(\"scrollEnded\", state);\r\n  }, 100);\r\n}\r\n\r\n/**\r\n * Responsible for assigning dragstart classes to the dragged nodes.\r\n */\r\nexport function handleDragstart<T>(\r\n  data: NodeDragEventData<T>,\r\n  _state: BaseDragState<T>\r\n) {\r\n  const config = data.targetData.parent.data.config;\r\n\r\n  if (\r\n    !config.nativeDrag ||\r\n    !validateDragstart(data) ||\r\n    !validateDragHandle({\r\n      x: data.e.clientX,\r\n      y: data.e.clientY,\r\n      node: data.targetData.node,\r\n      config,\r\n    })\r\n  ) {\r\n    pd(data.e);\r\n\r\n    return;\r\n  }\r\n\r\n  let nodes = config.draggedNodes({\r\n    parent: data.targetData.parent,\r\n    node: data.targetData.node,\r\n  });\r\n\r\n  // On Safari, pointerdown can sometimes not fire before the dragstart event.\r\n  if (nodes.length === 0) {\r\n    nodes = [data.targetData.node];\r\n  }\r\n\r\n  config.dragstartClasses(data.targetData.node, nodes, config);\r\n\r\n  const dragState = initDrag(data, nodes);\r\n\r\n  if (config.onDragstart) {\r\n    const dragstartData: DragstartEventData<T> = {\r\n      parent: data.targetData.parent,\r\n      values: parentValues(\r\n        data.targetData.parent.el,\r\n        data.targetData.parent.data\r\n      ),\r\n      draggedNode: dragState.draggedNode,\r\n      draggedNodes: dragState.draggedNodes,\r\n      position: dragState.initialIndex,\r\n      state: dragState,\r\n    };\r\n    config.onDragstart(dragstartData);\r\n  }\r\n}\r\n\r\nexport function handleNodePointerdown<T>(\r\n  data: NodePointerEventData<T>,\r\n  state: BaseDragState<T>\r\n) {\r\n  sp(data.e);\r\n\r\n  state.pointerDown = {\r\n    parent: data.targetData.parent,\r\n    node: data.targetData.node,\r\n    validated: false,\r\n  };\r\n\r\n  if (\r\n    !validateDragHandle({\r\n      x: data.e.clientX,\r\n      y: data.e.clientY,\r\n      node: data.targetData.node,\r\n      config: data.targetData.parent.data.config,\r\n    })\r\n  )\r\n    return;\r\n\r\n  state.pointerDown.validated = true;\r\n\r\n  handleLongPress(data, state, data.targetData.node);\r\n\r\n  const parentData = data.targetData.parent.data;\r\n\r\n  let selectedNodes = [data.targetData.node];\r\n\r\n  const commandKey = data.e.ctrlKey || data.e.metaKey;\r\n\r\n  const shiftKey = data.e.shiftKey;\r\n\r\n  const targetNode = data.targetData.node;\r\n\r\n  if (commandKey && parentData.config.multiDrag) {\r\n    if (state.selectedState) {\r\n      const idx = state.selectedState.nodes.findIndex(\r\n        (x) => x.el === targetNode.el\r\n      );\r\n\r\n      if (idx === -1) {\r\n        selectedNodes = [...state.selectedState.nodes, targetNode];\r\n      } else {\r\n        selectedNodes = state.selectedState.nodes.filter(\r\n          (x) => x.el !== targetNode.el\r\n        );\r\n      }\r\n    } else {\r\n      selectedNodes = [targetNode];\r\n    }\r\n\r\n    setSelected(\r\n      data.targetData.parent,\r\n      selectedNodes,\r\n      data.targetData.node,\r\n      state,\r\n      true\r\n    );\r\n\r\n    return;\r\n  }\r\n\r\n  if (shiftKey && parentData.config.multiDrag) {\r\n    const nodes = data.targetData.parent.data.enabledNodes;\r\n\r\n    if (state.selectedState && state.activeState) {\r\n      if (state.selectedState.parent.el !== data.targetData.parent.el) {\r\n        deselect(state.selectedState.nodes, state.selectedState.parent, state);\r\n\r\n        state.selectedState = undefined;\r\n\r\n        for (let x = 0; x <= targetNode.data.index; x++)\r\n          selectedNodes.push(nodes[x]);\r\n      } else {\r\n        const [minIndex, maxIndex] =\r\n          state.activeState.node.data.index < data.targetData.node.data.index\r\n            ? [\r\n                state.activeState.node.data.index,\r\n                data.targetData.node.data.index,\r\n              ]\r\n            : [\r\n                data.targetData.node.data.index,\r\n                state.activeState.node.data.index,\r\n              ];\r\n\r\n        selectedNodes = nodes.slice(minIndex, maxIndex + 1);\r\n      }\r\n    } else {\r\n      for (let x = 0; x <= targetNode.data.index; x++)\r\n        selectedNodes.push(nodes[x]);\r\n    }\r\n\r\n    setSelected(\r\n      data.targetData.parent,\r\n      selectedNodes,\r\n      data.targetData.node,\r\n      state,\r\n      true\r\n    );\r\n\r\n    return;\r\n  }\r\n\r\n  if (state.selectedState?.nodes?.length) {\r\n    const idx = state.selectedState.nodes.findIndex(\r\n      (x) => x.el === data.targetData.node.el\r\n    );\r\n\r\n    if (idx === -1) {\r\n      if (state.selectedState.parent.el !== data.targetData.parent.el) {\r\n        deselect(state.selectedState.nodes, data.targetData.parent, state);\r\n      } else if (parentData.config.multiDrag && isMobilePlatform()) {\r\n        selectedNodes.push(...state.selectedState.nodes);\r\n      } else {\r\n        deselect(state.selectedState.nodes, data.targetData.parent, state);\r\n      }\r\n\r\n      setSelected(\r\n        data.targetData.parent,\r\n        selectedNodes,\r\n        data.targetData.node,\r\n        state,\r\n        true\r\n      );\r\n    }\r\n  } else {\r\n    setSelected(\r\n      data.targetData.parent,\r\n      [data.targetData.node],\r\n      data.targetData.node,\r\n      state,\r\n      true\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Add dragstart classes to the nodes.\r\n *\r\n * @param node - The node.\r\n * @param nodes - The nodes.\r\n * @param config - The parent config.\r\n * @param isSynth - Whether the drag is synthetic.\r\n *\r\n * @returns void\r\n */\r\nexport function dragstartClasses<T>(\r\n  _node: NodeRecord<T>,\r\n  nodes: Array<NodeRecord<T>>,\r\n  config: ParentConfig<T>,\r\n  isSynth = false\r\n) {\r\n  addNodeClass(\r\n    nodes.map((x) => x.el),\r\n    isSynth ? config.synthDraggingClass : config.draggingClass\r\n  );\r\n\r\n  setTimeout(() => {\r\n    removeClass(\r\n      nodes.map((x) => x.el),\r\n      isSynth ? config.synthDraggingClass : config.draggingClass\r\n    );\r\n\r\n    addNodeClass(\r\n      nodes.map((x) => x.el),\r\n      isSynth ? config.synthDragPlaceholderClass : config.dragPlaceholderClass\r\n    );\r\n\r\n    addNodeClass(\r\n      nodes.map((x) => x.el),\r\n      isSynth ? config.synthDropZoneClass : config.dropZoneClass\r\n    );\r\n\r\n    removeClass(\r\n      nodes.map((x) => x.el),\r\n      config.selectedClass\r\n    );\r\n  });\r\n}\r\n\r\nexport function initDrag<T>(\r\n  data: NodeDragEventData<T>,\r\n  draggedNodes: Array<NodeRecord<T>>\r\n): DragState<T> {\r\n  sp(data.e);\r\n\r\n  const dragState = setDragState(\r\n    dragStateProps(\r\n      data.targetData.node,\r\n      data.targetData.parent,\r\n      data.e,\r\n      draggedNodes\r\n    )\r\n  );\r\n\r\n  if (data.e.dataTransfer) {\r\n    const config = data.targetData.parent.data.config;\r\n\r\n    data.e.dataTransfer.dropEffect = config.dragDropEffect;\r\n    data.e.dataTransfer.effectAllowed = config.dragEffectAllowed;\r\n\r\n    let dragImage: HTMLElement | undefined;\r\n\r\n    data.e.dataTransfer.setData(\"text/plain\", \"\");\r\n\r\n    if (config.dragImage) {\r\n      dragImage = config.dragImage(data, draggedNodes);\r\n    } else {\r\n      if (!config.multiDrag || draggedNodes.length === 1) {\r\n        dragState.originalZIndex = data.targetData.node.el.style.zIndex;\r\n\r\n        data.targetData.node.el.style.zIndex = \"9999\";\r\n        data.targetData.node.el.style.boxSizing = \"border-box\";\r\n\r\n        data.e.dataTransfer.setDragImage(\r\n          data.targetData.node.el,\r\n          data.e.offsetX,\r\n          data.e.offsetY\r\n        );\r\n        return dragState;\r\n      } else {\r\n        const wrapper = document.createElement(\"div\");\r\n\r\n        wrapper.setAttribute(\"id\", \"dnd-dragged-node-clone\");\r\n\r\n        wrapper.setAttribute(\"popover\", \"manual\");\r\n\r\n        for (const node of draggedNodes) {\r\n          const clone = node.el.cloneNode(true) as HTMLElement;\r\n\r\n          clone.id = node.el.id + \"-clone\";\r\n\r\n          clone.style.pointerEvents = \"none\";\r\n\r\n          wrapper.appendChild(clone);\r\n        }\r\n\r\n        const { width } = draggedNodes[0].el.getBoundingClientRect();\r\n\r\n        Object.assign(wrapper.style, {\r\n          display: \"flex\",\r\n          flexDirection: \"column\",\r\n          width: `${width}px`,\r\n          position: \"absolute\",\r\n          pointerEvents: \"none\",\r\n          zIndex: \"9999\",\r\n          left: \"-9999px\",\r\n          boxSizing: \"border-box\",\r\n          background: \"transparent\",\r\n          overflow: \"hidden\",\r\n        });\r\n\r\n        data.targetData.parent.el.appendChild(wrapper);\r\n\r\n        wrapper.showPopover();\r\n\r\n        wrapper.getBoundingClientRect(); // ← forces layout\r\n\r\n        dragImage = wrapper;\r\n\r\n        data.e.dataTransfer.setDragImage(\r\n          dragImage,\r\n          data.e.offsetX,\r\n          data.e.offsetY\r\n        );\r\n      }\r\n    }\r\n\r\n    setTimeout(() => {\r\n      dragImage?.remove();\r\n    });\r\n  }\r\n\r\n  return dragState;\r\n}\r\n\r\nexport function validateDragHandle<T>({\r\n  x,\r\n  y,\r\n  node,\r\n  config,\r\n}: {\r\n  x: number;\r\n  y: number;\r\n  node: NodeRecord<T>;\r\n  config: ParentConfig<T>;\r\n}): boolean {\r\n  if (config.externalDragHandle) return false;\r\n\r\n  if (!config.dragHandle) return true;\r\n\r\n  const dragHandles = node.el.querySelectorAll(config.dragHandle);\r\n\r\n  if (!dragHandles) return false;\r\n\r\n  const elFromPoint = config.root.elementFromPoint(x, y);\r\n\r\n  if (!elFromPoint) return false;\r\n\r\n  for (const handle of Array.from(dragHandles))\r\n    if (elFromPoint === handle || handle.contains(elFromPoint)) return true;\r\n\r\n  return false;\r\n}\r\n\r\nexport function handleClickNode<T>(_data: NodeEventData<T>) {}\r\n\r\nexport function handleClickParent<T>(_data: ParentEventData<T>) {}\r\n\r\nexport function handleNodeKeydown<T>(_data: NodeEventData<T>) {}\r\n\r\n/**\r\n * Prevent the sort on scroll.\r\n *\r\n * @returns A function to prevent the sort on scroll.\r\n */\r\nexport function preventSortOnScroll() {\r\n  let scrollTimeout: ReturnType<typeof setTimeout>;\r\n\r\n  return () => {\r\n    clearTimeout(scrollTimeout);\r\n\r\n    if (state) state.preventEnter = true;\r\n\r\n    scrollTimeout = setTimeout(() => {\r\n      if (state) state.preventEnter = false;\r\n    }, 100);\r\n  };\r\n}\r\n\r\n/**\r\n * Handle the node pointer over.\r\n *\r\n * @param e - The node pointer over event.\r\n *\r\n * @returns void\r\n */\r\nexport function handleNodePointerover<T>(e: PointeroverNodeEvent<T>) {\r\n  if (e.detail.targetData.parent.el === e.detail.state.currentParent.el)\r\n    sort(e.detail, e.detail.state);\r\n  else transfer(e.detail, e.detail.state);\r\n}\r\n\r\n/**\r\n * Handle the node drop.\r\n *\r\n * @param data - The node drag event data.\r\n * @param state - The drag state.\r\n *\r\n * @returns void\r\n */\r\nexport function handleNodeDrop<T>(\r\n  data: NodeDragEventData<T>,\r\n  state: DragState<T> | SynthDragState<T>\r\n) {\r\n  const config = data.targetData.parent.data.config;\r\n\r\n  if (!config.nativeDrag) return;\r\n\r\n  sp(data.e);\r\n\r\n  dropped = true;\r\n\r\n  config.handleEnd(state);\r\n}\r\n\r\nexport function handleNodeFocus<T>(data: NodeEventData<T>) {\r\n  if (data.e.target === data.e.currentTarget) return;\r\n\r\n  if (state.pointerDown) state.pointerDown.node.el.draggable = false;\r\n}\r\n\r\nexport function handleNodeBlur<T>(data: NodeEventData<T>) {\r\n  if (data.e.target === data.e.currentTarget) return;\r\n\r\n  if (state.pointerDown) state.pointerDown.node.el.draggable = true;\r\n}\r\n\r\n/**\r\n * Handle the drag end.\r\n *\r\n * @param data - The node drag event data.\r\n * @param state - The drag state.\r\n *\r\n * @returns void\r\n */\r\nexport function handleDragend<T>(\r\n  data: NodeDragEventData<T>,\r\n  state: DragState<T>\r\n) {\r\n  const config = data.targetData.parent.data.config;\r\n\r\n  if (!config.nativeDrag) return;\r\n\r\n  pd(data.e);\r\n\r\n  sp(data.e);\r\n\r\n  if (dropped) {\r\n    dropped = false;\r\n\r\n    return;\r\n  }\r\n\r\n  config.handleEnd(state);\r\n}\r\n\r\n/**\r\n * Handle the pointer cancel.\r\n *\r\n * @param data - The node event data.\r\n * @param state - The drag state.\r\n *\r\n * @returns void\r\n */\r\nexport function handlePointercancel<T>(\r\n  data: NodeEventData<T>,\r\n  state: DragState<T> | SynthDragState<T> | BaseDragState<T>\r\n) {\r\n  if (!isSynthDragState(state)) return;\r\n\r\n  pd(data.e);\r\n\r\n  if (dropped) {\r\n    dropped = false;\r\n\r\n    return;\r\n  }\r\n\r\n  const config = parents.get(state.initialParent.el)?.config;\r\n\r\n  if (config?.onDragend) {\r\n    config.onDragend({\r\n      parent: state.currentParent,\r\n      values: parentValues(state.currentParent.el, state.currentParent.data),\r\n      draggedNode: state.draggedNode,\r\n      draggedNodes: state.draggedNodes,\r\n      state,\r\n    });\r\n  }\r\n\r\n  config?.handleEnd(state);\r\n}\r\n\r\n/**\r\n * Handle the drag end.\r\n *\r\n * @param state - The drag state.\r\n *\r\n * @returns void\r\n */\r\nexport function handleEnd<T>(state: DragState<T> | SynthDragState<T>) {\r\n  if (state.draggedNode) state.draggedNode.el.draggable = true;\r\n\r\n  // --- Capture necessary data BEFORE resetState might affect it ---\r\n  const nodesToClean = state.draggedNodes.map((x) => x.el);\r\n  const initialParentData = state.initialParent.data;\r\n  const isSynth = isSynthDragState(state);\r\n  const config = parents.get(state.initialParent.el)?.config;\r\n  const dropZoneClass = isSynth\r\n    ? config?.synthDropZoneClass\r\n    : config?.dropZoneClass;\r\n  const longPressClass = initialParentData?.config?.longPressClass;\r\n  const placeholderClass = isSynth\r\n    ? initialParentData?.config?.synthDragPlaceholderClass // Corrected potential typo: used initialParentData\r\n    : initialParentData?.config?.dragPlaceholderClass;\r\n  const originalZIndex = state.originalZIndex;\r\n  // --- End data capture ---\r\n\r\n  if (isSynthDragState(state)) {\r\n    // Ensure cloned node removal happens reasonably quickly\r\n    if (state.clonedDraggedNode) {\r\n      // Check if it exists\r\n      state.clonedDraggedNode.remove();\r\n    }\r\n    if (state.longPressTimeout) {\r\n      // Check if timeout exists\r\n      clearTimeout(state.longPressTimeout);\r\n    }\r\n  }\r\n\r\n  // Ensure scrolling is properly cancelled (needs state, do before reset)\r\n  cancelSynthScroll(state);\r\n\r\n  // Clear any lingering scroll directions and timeouts (needs state, do before reset)\r\n  state.lastScrollDirectionX = undefined;\r\n  state.lastScrollDirectionY = undefined;\r\n  state.preventEnter = false;\r\n  if (state.scrollDebounceTimeout) {\r\n    clearTimeout(state.scrollDebounceTimeout);\r\n    state.scrollDebounceTimeout = undefined; // Ensure it's marked as cleared\r\n  }\r\n\r\n  // Apply z-index change synchronously if needed\r\n  if (originalZIndex !== undefined && state.draggedNode) {\r\n    state.draggedNode.el.style.zIndex = originalZIndex;\r\n  }\r\n\r\n  // Use single rAF with captured data for class removal\r\n  requestAnimationFrame(() => {\r\n    // Use the captured data, not the potentially reset global state\r\n    removeClass(nodesToClean, dropZoneClass);\r\n    removeClass(nodesToClean, longPressClass);\r\n    removeClass(nodesToClean, placeholderClass);\r\n  });\r\n\r\n  // Deselect and reset active state (needs state, do before reset)\r\n  deselect(state.draggedNodes, state.currentParent, state);\r\n  setActive(state.currentParent, undefined, state);\r\n\r\n  // Prepare data for callback/event *before* resetState\r\n  const finalStateForCallback = { ...state }; // Shallow copy for safety\r\n\r\n  // Call onDragend callback *before* resetState\r\n  config?.onDragend?.({\r\n    parent: finalStateForCallback.currentParent,\r\n    values: parentValues(\r\n      finalStateForCallback.currentParent.el,\r\n      finalStateForCallback.currentParent.data\r\n    ),\r\n    draggedNode: finalStateForCallback.draggedNode,\r\n    draggedNodes: finalStateForCallback.draggedNodes,\r\n    state: finalStateForCallback,\r\n  });\r\n\r\n  // Emit event *before* resetState\r\n  state.emit(\"dragEnded\", finalStateForCallback); // Emit with the final state representation\r\n\r\n  // Reset global state LAST\r\n  resetState();\r\n\r\n  // No need to set state.selectedState = undefined; resetState handles it.\r\n}\r\n\r\n/**\r\n * Handle the node pointer up.\r\n *\r\n * @param data - The node pointer event data.\r\n * @param state - The drag state.\r\n *\r\n * @returns void\r\n */\r\nexport function handleNodePointerup<T>(\r\n  data: NodePointerEventData<T>,\r\n  state: DragState<T> | SynthDragState<T> | BaseDragState<T>\r\n) {\r\n  sp(data.e);\r\n\r\n  if (!state.pointerSelection && state.selectedState)\r\n    deselect(state.selectedState.nodes, data.targetData.parent, state);\r\n\r\n  const config = data.targetData.parent.data.config;\r\n\r\n  state.pointerSelection = false;\r\n\r\n  if (\"longPressTimeout\" in state && state.longPressTimeout)\r\n    clearTimeout(state.longPressTimeout);\r\n\r\n  state.longPress = false;\r\n\r\n  removeClass(\r\n    data.targetData.parent.data.enabledNodes.map((x) => x.el),\r\n    config.longPressClass\r\n  );\r\n\r\n  if (!isDragState(state)) return;\r\n\r\n  config.handleEnd(state as DragState<T> | SynthDragState<T>);\r\n}\r\n\r\n/**\r\n * Initialize the synth drag.\r\n *\r\n * @param node - The node.\r\n * @param parent - The parent.\r\n * @param e - The pointer event.\r\n * @param _state - The drag state.\r\n * @param draggedNodes - The dragged nodes.\r\n * @param rect - The bounding rect of the original element\r\n *\r\n * @returns The synth drag state.\r\n */\r\nfunction initSynthDrag<T>(\r\n  node: NodeRecord<T>,\r\n  parent: ParentRecord<T>,\r\n  e: PointerEvent,\r\n  _state: BaseDragState<T>,\r\n  draggedNodes: Array<NodeRecord<T>>,\r\n  rect: DOMRect\r\n): SynthDragState<T> {\r\n  const config = parent.data.config;\r\n\r\n  let dragImage: HTMLElement;\r\n\r\n  let result:\r\n    | { dragImage: HTMLElement; offsetX?: number; offsetY?: number }\r\n    | undefined;\r\n\r\n  const criticalStyleProps = [\r\n    \"display\",\r\n    \"flexDirection\",\r\n    \"alignItems\",\r\n    \"justifyContent\",\r\n    \"padding\",\r\n    \"paddingTop\",\r\n    \"margin\",\r\n    \"marginTop\",\r\n    \"marginBottom\",\r\n    \"marginLeft\",\r\n    \"marginRight\",\r\n    \"paddingBottom\",\r\n    \"paddingLeft\",\r\n    \"paddingRight\",\r\n    \"border\",\r\n    \"borderRadius\",\r\n    \"background\",\r\n    \"backgroundColor\",\r\n    \"boxShadow\",\r\n    \"font\",\r\n    \"color\",\r\n    \"lineHeight\",\r\n    \"gap\",\r\n    \"width\",\r\n    \"height\",\r\n    \"boxSizing\",\r\n    \"overflow\",\r\n  ] as const;\r\n\r\n  const copyCriticalStyles = (src: HTMLElement, dest: HTMLElement) => {\r\n    const computed = window.getComputedStyle(src);\r\n    criticalStyleProps.forEach((prop) => {\r\n      dest.style[prop] = computed[prop]!;\r\n    });\r\n  };\r\n\r\n  // Helper to style the drag image\r\n  const applyBaseStyles = (\r\n    el: HTMLElement,\r\n    extraStyles: Partial<CSSStyleDeclaration> = {}\r\n  ) => {\r\n    Object.assign(el.style, {\r\n      position: \"absolute\",\r\n      zIndex: \"9999\",\r\n      pointerEvents: \"none\",\r\n      willChange: \"transform\",\r\n      boxSizing: \"border-box\",\r\n      opacity: \"0\",\r\n      overflow: \"hidden\",\r\n      width: `${rect.width}px`,\r\n      height: `${rect.height}px`,\r\n      ...extraStyles,\r\n    });\r\n  };\r\n\r\n  // Custom drag image\r\n  if (config.synthDragImage) {\r\n    result = config.synthDragImage(node, parent, e, draggedNodes);\r\n    dragImage = result.dragImage;\r\n    dragImage.setAttribute(\"popover\", \"manual\");\r\n    applyBaseStyles(dragImage);\r\n  }\r\n\r\n  // Single drag\r\n  else if (!config.multiDrag || draggedNodes.length === 1) {\r\n    dragImage = node.el.cloneNode(true) as HTMLElement;\r\n    copyCriticalStyles(node.el as HTMLElement, dragImage);\r\n    dragImage.setAttribute(\"popover\", \"manual\");\r\n    applyBaseStyles(dragImage);\r\n  }\r\n\r\n  // Multi-drag\r\n  else {\r\n    const wrapper = document.createElement(\"div\");\r\n\r\n    wrapper.setAttribute(\"popover\", \"manual\");\r\n\r\n    draggedNodes.forEach((dragged) => {\r\n      const clone = dragged.el.cloneNode(true) as HTMLElement;\r\n\r\n      copyCriticalStyles(dragged.el as HTMLElement, clone);\r\n\r\n      clone.style.pointerEvents = \"none\";\r\n\r\n      clone.style.margin = \"0\";\r\n\r\n      wrapper.append(clone);\r\n    });\r\n\r\n    wrapper.style.display = \"flex\";\r\n    wrapper.style.flexDirection = \"column\";\r\n    wrapper.style.padding = \"0\";\r\n    wrapper.style.margin = \"0\";\r\n    wrapper.style.position = \"absolute\";\r\n    wrapper.style.zIndex = \"9999\";\r\n    wrapper.style.pointerEvents = \"none\";\r\n\r\n    dragImage = wrapper;\r\n  }\r\n\r\n  dragImage.id = \"dnd-dragged-node-clone\";\r\n\r\n  parent.el.appendChild(dragImage);\r\n\r\n  dragImage.showPopover();\r\n\r\n  const synthDragStateProps = {\r\n    clonedDraggedEls: [],\r\n    clonedDraggedNode: dragImage,\r\n    synthDragScrolling: false,\r\n    synthDragging: true,\r\n    rootScrollWidth: document.scrollingElement?.scrollWidth,\r\n    rootScrollHeight: document.scrollingElement?.scrollHeight,\r\n  };\r\n\r\n  const synthDragState = setDragState({\r\n    ...dragStateProps(\r\n      node,\r\n      parent,\r\n      e,\r\n      draggedNodes,\r\n      result?.offsetX,\r\n      result?.offsetY\r\n    ),\r\n    ...synthDragStateProps,\r\n  }) as SynthDragState<T>;\r\n\r\n  return synthDragState;\r\n}\r\n\r\n/**\r\n * Handle the long press.\r\n *\r\n * @param data - The node pointer event data.\r\n * @param state - The drag state.\r\n * @param node - The node.\r\n *\r\n * @returns void\r\n */\r\nexport function handleLongPress<T>(\r\n  data: NodePointerEventData<T>,\r\n  state: BaseDragState<T>,\r\n  node: NodeRecord<T>\r\n) {\r\n  const config = data.targetData.parent.data.config;\r\n\r\n  state.longPressTimeout = setTimeout(() => {\r\n    if (!state) return;\r\n\r\n    state.longPress = true;\r\n\r\n    if (config.longPressClass && data.e.cancelable)\r\n      addNodeClass([node.el], config.longPressClass);\r\n\r\n    pd(data.e);\r\n  }, config.longPressDuration || 1000);\r\n}\r\n\r\nfunction cancelSynthScroll<T>(\r\n  state: DragState<T>,\r\n  cancelX = true,\r\n  cancelY = true\r\n) {\r\n  if (cancelX) {\r\n    if (state.frameIdX !== undefined) {\r\n      cancelAnimationFrame(state.frameIdX);\r\n      state.frameIdX = undefined;\r\n    }\r\n    state.lastScrollDirectionX = undefined;\r\n  }\r\n\r\n  if (cancelY) {\r\n    if (state.frameIdY !== undefined) {\r\n      cancelAnimationFrame(state.frameIdY);\r\n      state.frameIdY = undefined;\r\n    }\r\n    state.lastScrollDirectionY = undefined;\r\n  }\r\n\r\n  if (!state.frameIdX && !state.frameIdY) {\r\n    state.preventEnter = false;\r\n  }\r\n}\r\n\r\nfunction moveNode<T>(state: SynthDragState<T>, justStarted = false) {\r\n  const { x, y } = state.coordinates;\r\n\r\n  const startLeft = state.startLeft ?? 0;\r\n  const startTop = state.startTop ?? 0;\r\n\r\n  const currentScrollX = window.scrollX ?? 0;\r\n  const currentScrollY = window.scrollY ?? 0;\r\n\r\n  const translateX = x - startLeft + currentScrollX;\r\n  const translateY = y - startTop + currentScrollY;\r\n\r\n  state.clonedDraggedNode.style.transform = `translate3d(${translateX}px, ${translateY}px, 0px)`;\r\n\r\n  if (justStarted) {\r\n    state.clonedDraggedNode.style.opacity = \"1\";\r\n\r\n    removeClass(\r\n      state.draggedNodes.map((x) => x.el),\r\n      state.initialParent.data.config?.longPressClass\r\n    );\r\n  }\r\n}\r\n\r\nexport function synthMove<T>(\r\n  e: PointerEvent,\r\n  state: SynthDragState<T>,\r\n  justStarted = false\r\n) {\r\n  const coordinates = eventCoordinates(e);\r\n  state.coordinates.x = coordinates.x;\r\n  state.coordinates.y = coordinates.y;\r\n\r\n  moveNode(state, justStarted); // Pass only state now\r\n\r\n  // Clear any existing timeout to avoid multiple concurrent timeouts\r\n  if (state.scrollDebounceTimeout) {\r\n    clearTimeout(state.scrollDebounceTimeout);\r\n    state.scrollDebounceTimeout = undefined;\r\n  }\r\n\r\n  // Only set a new timeout if we're still in a valid drag state\r\n  state.scrollDebounceTimeout = setTimeout(() => {\r\n    // Only process if the drag state is still active\r\n    if (isSynthDragState(state)) {\r\n      handleSynthScroll(state.coordinates, e, state);\r\n    }\r\n  }, 16); // ~1 frame (60fps)\r\n\r\n  const elFromPoint = getElFromPoint(coordinates);\r\n\r\n  if (!elFromPoint) {\r\n    document.dispatchEvent(\r\n      new CustomEvent(\"handleRootPointerover\", {\r\n        detail: {\r\n          e,\r\n          state,\r\n        },\r\n      })\r\n    );\r\n\r\n    return;\r\n  }\r\n\r\n  const pointerMoveEventData = {\r\n    e,\r\n    targetData: elFromPoint,\r\n    state,\r\n  };\r\n\r\n  if (\"node\" in elFromPoint) {\r\n    elFromPoint.node.el.dispatchEvent(\r\n      new CustomEvent(\"handleNodePointerover\", {\r\n        detail: pointerMoveEventData,\r\n      })\r\n    );\r\n  } else {\r\n    elFromPoint.parent.el.dispatchEvent(\r\n      new CustomEvent(\"handleParentPointerover\", {\r\n        detail: pointerMoveEventData,\r\n      })\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Handle the node drag over.\r\n *\r\n * @param data - The node drag event data.\r\n * @param state - The drag state.\r\n *\r\n * @returns void\r\n */\r\nexport function handleNodeDragover<T>(\r\n  data: NodeDragEventData<T>,\r\n  state: DragState<T>\r\n) {\r\n  const config = data.targetData.parent.data.config;\r\n\r\n  if (!config.nativeDrag) return;\r\n\r\n  const { x, y } = eventCoordinates(data.e);\r\n\r\n  state.coordinates.y = y;\r\n\r\n  state.coordinates.x = x;\r\n\r\n  pd(data.e);\r\n\r\n  sp(data.e);\r\n\r\n  if (isDragState(state)) {\r\n    handleSynthScroll({ x, y }, data.e, state);\r\n  }\r\n\r\n  data.targetData.parent.el === state.currentParent?.el\r\n    ? sort(data, state)\r\n    : transfer(data, state);\r\n}\r\n\r\n/**\r\n * Handle the parent drag over.\r\n *\r\n * @param data - The parent drag event data.\r\n * @param state - The drag state.\r\n *\r\n * @returns void\r\n */\r\nexport function handleParentDragover<T>(\r\n  data: ParentDragEventData<T>,\r\n  state: DragState<T>\r\n) {\r\n  const config = data.targetData.parent.data.config;\r\n\r\n  if (!config.nativeDrag) return;\r\n\r\n  pd(data.e);\r\n\r\n  sp(data.e);\r\n\r\n  const { x, y } = eventCoordinates(data.e);\r\n\r\n  if (isDragState(state)) {\r\n    handleSynthScroll({ x, y }, data.e, state);\r\n  }\r\n\r\n  transfer(data, state);\r\n}\r\n\r\n/**\r\n * Handle the parent pointer over.\r\n *\r\n * @param e - The parent pointer over event.\r\n *\r\n * @returns void\r\n */\r\nexport function handleParentPointerover<T>(e: PointeroverParentEvent<T>) {\r\n  if (e.detail.targetData.parent.el !== e.detail.state.currentParent.el)\r\n    transfer(e.detail, e.detail.state);\r\n}\r\n\r\n/**\r\n * Validate the transfer.\r\n *\r\n * @param data - The transfer data.\r\n *\r\n * @returns Whether the transfer is valid.\r\n */\r\nexport function validateTransfer<T>({\r\n  currentParent,\r\n  targetParent,\r\n  initialParent,\r\n  draggedNodes,\r\n  state,\r\n}: {\r\n  currentParent: ParentRecord<T>;\r\n  targetParent: ParentRecord<T>;\r\n  initialParent: ParentRecord<T>;\r\n  draggedNodes: Array<NodeRecord<T>>;\r\n  state: BaseDragState<T>;\r\n}) {\r\n  if (targetParent.el === currentParent.el) return false;\r\n\r\n  const targetConfig = targetParent.data.config;\r\n\r\n  if (draggedNodes[0].el.contains(targetParent.el)) return false;\r\n\r\n  if (targetConfig.dropZone === false) return false;\r\n\r\n  const initialParentConfig = initialParent.data.config;\r\n\r\n  if (targetConfig.accepts) {\r\n    return targetConfig.accepts(\r\n      targetParent,\r\n      initialParent,\r\n      currentParent,\r\n      state\r\n    );\r\n  } else if (\r\n    !targetConfig.group ||\r\n    targetConfig.group !== initialParentConfig.group\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Handle the node drag enter.\r\n *\r\n * @param data - The node drag event data.\r\n * @param _state - The drag state.\r\n *\r\n * @returns void\r\n */\r\nfunction handleNodeDragenter<T>(\r\n  data: NodeDragEventData<T>,\r\n  _state: DragState<T>\r\n) {\r\n  pd(data.e);\r\n}\r\n\r\n/**\r\n * Handle the node drag leave.\r\n *\r\n * @param data - The node drag event data.\r\n * @param _state - The drag state.\r\n *\r\n * @returns void\r\n */\r\nfunction handleNodeDragleave<T>(\r\n  data: NodeDragEventData<T>,\r\n  _state: DragState<T>\r\n) {\r\n  pd(data.e);\r\n}\r\n\r\n/**\r\n * Validate the sort.\r\n *\r\n * @param data - The node drag event data or node pointer event data.\r\n * @param state - The drag state.\r\n * @param x - The x coordinate.\r\n * @param y - The y coordinate.\r\n *\r\n * @returns Whether the sort is valid.\r\n */\r\nexport function validateSort<T>(\r\n  data: NodeDragEventData<T> | NodePointerEventData<T>,\r\n  state: DragState<T>,\r\n  x: number,\r\n  y: number\r\n): boolean {\r\n  if (\r\n    state.affectedNodes\r\n      .map((x) => x.data.value)\r\n      .includes(data.targetData.node.data.value)\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  if (state.remapJustFinished) {\r\n    state.remapJustFinished = false;\r\n\r\n    if (\r\n      data.targetData.node.data.value === state.currentTargetValue ||\r\n      state.draggedNodes.map((x) => x.el).includes(data.targetData.node.el)\r\n    ) {\r\n      state.currentTargetValue = data.targetData.node.data.value;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  if (state.preventEnter) return false;\r\n\r\n  if (state.draggedNodes.map((x) => x.el).includes(data.targetData.node.el)) {\r\n    state.currentTargetValue = undefined;\r\n\r\n    return false;\r\n  }\r\n\r\n  if (data.targetData.node.data.value === state.currentTargetValue)\r\n    return false;\r\n\r\n  if (\r\n    data.targetData.parent.el !== state.currentParent?.el ||\r\n    data.targetData.parent.data.config.sortable === false\r\n  )\r\n    return false;\r\n\r\n  if (data.targetData.node.el.contains(state.draggedNodes[0].el)) return false;\r\n\r\n  const targetRect = data.targetData.node.el.getBoundingClientRect();\r\n\r\n  const dragRect = state.draggedNode.el.getBoundingClientRect();\r\n\r\n  const yDiff = targetRect.y - dragRect.y;\r\n\r\n  const xDiff = targetRect.x - dragRect.x;\r\n\r\n  let incomingDirection: \"above\" | \"below\" | \"left\" | \"right\";\r\n\r\n  if (Math.abs(yDiff) > Math.abs(xDiff)) {\r\n    incomingDirection = yDiff > 0 ? \"above\" : \"below\";\r\n  } else {\r\n    incomingDirection = xDiff > 0 ? \"left\" : \"right\";\r\n  }\r\n\r\n  const threshold = state.currentParent.data.config.threshold;\r\n\r\n  switch (incomingDirection) {\r\n    case \"left\":\r\n      if (x > targetRect.x + targetRect.width * threshold.horizontal) {\r\n        state.incomingDirection = \"left\";\r\n\r\n        return true;\r\n      }\r\n      break;\r\n\r\n    case \"right\":\r\n      if (x < targetRect.x + targetRect.width * (1 - threshold.horizontal)) {\r\n        state.incomingDirection = \"right\";\r\n\r\n        return true;\r\n      }\r\n      break;\r\n\r\n    case \"above\":\r\n      if (y > targetRect.y + targetRect.height * threshold.vertical) {\r\n        state.incomingDirection = \"above\";\r\n\r\n        return true;\r\n      }\r\n      break;\r\n\r\n    case \"below\":\r\n      if (y < targetRect.y + targetRect.height * (1 - threshold.vertical)) {\r\n        state.incomingDirection = \"below\";\r\n\r\n        return true;\r\n      }\r\n      break;\r\n\r\n    default:\r\n      break;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Sort the nodes.\r\n *\r\n * @param data - The node drag event data or node pointer event data.\r\n * @param state - The drag state.\r\n *\r\n * @returns void\r\n */\r\nexport function sort<T>(\r\n  data: NodeDragEventData<T> | NodePointerEventData<T>,\r\n  state: DragState<T>\r\n) {\r\n  const { x, y } = eventCoordinates(data.e);\r\n\r\n  if (!validateSort(data, state, x, y)) {\r\n    return;\r\n  }\r\n\r\n  const range =\r\n    state.draggedNode.data.index > data.targetData.node.data.index\r\n      ? [data.targetData.node.data.index, state.draggedNode.data.index]\r\n      : [state.draggedNode.data.index, data.targetData.node.data.index];\r\n\r\n  state.targetIndex = data.targetData.node.data.index;\r\n\r\n  state.affectedNodes = data.targetData.parent.data.enabledNodes.filter(\r\n    (node) => {\r\n      return (\r\n        range[0] <= node.data.index &&\r\n        node.data.index <= range[1] &&\r\n        node.el !== state.draggedNode.el\r\n      );\r\n    }\r\n  );\r\n\r\n  data.targetData.parent.data.config.performSort({\r\n    parent: data.targetData.parent,\r\n    draggedNodes: state.draggedNodes,\r\n    targetNodes: [data.targetData.node],\r\n  });\r\n}\r\n\r\n/**\r\n * Event listener used for all nodes.\r\n *\r\n * @param e - The event.\r\n *\r\n */\r\nexport function nodeEventData<T>(\r\n  callback: any\r\n): (e: Event) => NodeEventData<T> | undefined {\r\n  function nodeTargetData(node: Node): NodeTargetData<T> | undefined {\r\n    const nodeData = nodes.get(node);\r\n\r\n    if (!nodeData) return;\r\n\r\n    const parentData = parents.get(node.parentNode);\r\n\r\n    if (!parentData) return;\r\n\r\n    return {\r\n      node: {\r\n        el: node,\r\n        data: nodeData,\r\n      },\r\n      parent: {\r\n        el: node.parentNode,\r\n        data: parentData,\r\n      },\r\n    };\r\n  }\r\n\r\n  return (e: Event) => {\r\n    const targetData = nodeTargetData(e.currentTarget as Node);\r\n\r\n    if (!targetData) return;\r\n\r\n    return callback(\r\n      {\r\n        e,\r\n        targetData,\r\n      },\r\n      state\r\n    );\r\n  };\r\n}\r\n\r\n/**\r\n * Transfer the nodes.\r\n *\r\n * @param data - The node event data or parent event data.\r\n * @param state - The drag state.\r\n *\r\n * @returns void\r\n */\r\nexport function transfer<T>(\r\n  data: NodeEventData<T> | ParentEventData<T>,\r\n  state: DragState<T>\r\n): void {\r\n  pd(data.e);\r\n\r\n  if (\r\n    !validateTransfer({\r\n      currentParent: state.currentParent,\r\n      targetParent: data.targetData.parent as any,\r\n      initialParent: state.initialParent,\r\n      draggedNodes: state.draggedNodes,\r\n      state,\r\n    })\r\n  )\r\n    return;\r\n\r\n  data.targetData.parent.data.config.performTransfer({\r\n    currentParent: state.currentParent,\r\n    targetParent: data.targetData.parent,\r\n    initialParent: state.initialParent,\r\n    draggedNodes: state.draggedNodes,\r\n    initialIndex: state.initialIndex,\r\n    state,\r\n    targetNodes: \"node\" in data.targetData ? [data.targetData.node] : [],\r\n  });\r\n\r\n  state.currentParent = data.targetData.parent;\r\n\r\n  state.transferred = true;\r\n}\r\n\r\n/**\r\n * Event listener used for all parents.\r\n *\r\n * @param callback - The callback.\r\n *\r\n * @returns A function to get the parent event data.\r\n */\r\nexport function parentEventData<T>(\r\n  callback: any\r\n): (e: Event) => NodeEventData<T> | undefined {\r\n  function parentTargetData(\r\n    parent: HTMLElement\r\n  ): ParentTargetData<T> | undefined {\r\n    const parentData = parents.get(parent);\r\n\r\n    if (!parentData) return;\r\n\r\n    return {\r\n      parent: {\r\n        el: parent,\r\n        data: parentData as ParentData<T>,\r\n      },\r\n    };\r\n  }\r\n\r\n  return (e: Event) => {\r\n    const targetData = parentTargetData(e.currentTarget as HTMLElement);\r\n\r\n    if (!targetData) return;\r\n\r\n    return callback(\r\n      {\r\n        e,\r\n        targetData,\r\n      },\r\n      state\r\n    );\r\n  };\r\n}\r\n\r\n/**\r\n * Add class to the node.\r\n *\r\n * @param els - The nodes.\r\n * @param className - The class name.\r\n * @param omitAppendPrivateClass - Whether to omit append private class.\r\n *\r\n * @returns void\r\n */\r\nexport function addNodeClass<T>(\r\n  els: Array<Node | HTMLElement | Element>,\r\n  className: string | undefined,\r\n  omitAppendPrivateClass = false\r\n) {\r\n  function nodeSetter<T>(node: Node, nodeData: NodeData<T>) {\r\n    nodes.set(node, nodeData);\r\n  }\r\n\r\n  for (const el of els) {\r\n    const nodeData = nodes.get(el as Node);\r\n\r\n    const newData = addClass(el, className, nodeData, omitAppendPrivateClass);\r\n\r\n    if (!newData) continue;\r\n\r\n    nodeSetter(el as Node, newData as NodeData<T>);\r\n  }\r\n}\r\n\r\n/**\r\n * Add class to the parent.\r\n *\r\n * @param els - The parents.\r\n * @param className - The class name.\r\n * @param omitAppendPrivateClass - Whether to omit append private class.\r\n *\r\n * @returns void\r\n */\r\nexport function addParentClass<T>(\r\n  els: Array<HTMLElement>,\r\n  className: string | undefined,\r\n  omitAppendPrivateClass = false\r\n) {\r\n  function parentSetter<T>(parent: HTMLElement, parentData: ParentData<T>) {\r\n    parents.set(parent, parentData);\r\n  }\r\n\r\n  for (const el of els) {\r\n    const parentData = parents.get(el);\r\n\r\n    const newData = addClass(el, className, parentData, omitAppendPrivateClass);\r\n\r\n    if (!newData) continue;\r\n\r\n    parentSetter(el, newData as ParentData<T>);\r\n  }\r\n}\r\n\r\n/**\r\n * Add class to the node.\r\n *\r\n * @param el - The node.\r\n * @param className - The class name.\r\n * @param data - The node data.\r\n * @param omitAppendPrivateClass - Whether to omit append private class.\r\n *\r\n * @returns void\r\n */\r\nexport function addClass(\r\n  el: Node | HTMLElement | Element,\r\n  className: string | undefined,\r\n  data: NodeData<any> | ParentData<any> | undefined,\r\n  omitAppendPrivateClass = false\r\n) {\r\n  if (!className) return;\r\n\r\n  const classNames = splitClass(className);\r\n\r\n  if (!classNames.length) return;\r\n\r\n  if (!data) {\r\n    el.classList.add(...classNames);\r\n    return;\r\n  }\r\n  // Revert to original logic: Initialize privateClasses as empty for this call.\r\n  const privateClasses = [];\r\n\r\n  for (const currentClassName of classNames) {\r\n    if (!el.classList.contains(currentClassName)) {\r\n      el.classList.add(currentClassName);\r\n    } else if (\r\n      // Only add to privateClasses if the element already had the class\r\n      // AND omitAppendPrivateClass is specifically false for THIS call.\r\n      el.classList.contains(currentClassName) &&\r\n      omitAppendPrivateClass === false\r\n    ) {\r\n      privateClasses.push(currentClassName);\r\n    }\r\n  }\r\n  // Assign the newly computed privateClasses, overwriting any previous value.\r\n  data.privateClasses = privateClasses;\r\n  return data;\r\n}\r\n\r\n/**\r\n * Remove class from the nodes.\r\n *\r\n * @param els - The nodes.\r\n * @param className - The class name.\r\n *\r\n * @returns void\r\n */\r\nexport function removeClass(\r\n  els: Array<Node | HTMLElement | Element>,\r\n  className: string | undefined\r\n) {\r\n  if (!className) return;\r\n\r\n  const classNames = splitClass(className);\r\n\r\n  if (!classNames.length) return;\r\n\r\n  for (const node of els) {\r\n    if (!isNode(node)) {\r\n      node.classList.remove(...classNames);\r\n      continue;\r\n    }\r\n\r\n    const nodeData = nodes.get(node) || parents.get(node);\r\n\r\n    if (!nodeData) continue;\r\n\r\n    for (const className of classNames) {\r\n      if (!nodeData.privateClasses.includes(className)) {\r\n        node.classList.remove(className);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ntype ScrollDirection<T> = { axis: \"x\"; state: DragState<T> } | { axis: \"y\" };\r\n\r\nfunction getScrollDirection<T>(\r\n  el: HTMLElement,\r\n  e: PointerEvent | DragEvent,\r\n  style: CSSStyleDeclaration,\r\n  rect: DOMRect,\r\n  opts: ScrollDirection<T>\r\n): Record<string, boolean> {\r\n  const threshold = 0.075;\r\n\r\n  const isX = opts.axis === \"x\";\r\n  const isRoot = el === document.scrollingElement;\r\n  const scrollProp = isX ? \"scrollLeft\" : \"scrollTop\";\r\n  const sizeProp = isX ? \"clientWidth\" : \"clientHeight\";\r\n  const offsetProp = isX ? \"offsetWidth\" : \"offsetHeight\";\r\n  const scrollSizeProp = isX ? \"scrollWidth\" : \"scrollHeight\";\r\n  const clientCoord = isX ? e.clientX : e.clientY;\r\n  const rectStart = isX ? rect.left : rect.top;\r\n  const overflow = isX ? style.overflowX : style.overflowY;\r\n\r\n  if (isRoot) {\r\n    const scrollPos = el[scrollProp];\r\n    const clientSize = el[sizeProp];\r\n    const canScrollBefore = scrollPos > 0;\r\n    const canScrollAfter =\r\n      scrollPos + clientSize <\r\n      (isX\r\n        ? (opts.state as SynthDragState<T>).rootScrollWidth || 0\r\n        : el[scrollSizeProp]);\r\n\r\n    return isX\r\n      ? {\r\n          left: canScrollBefore && clientCoord < clientSize * threshold,\r\n          right: canScrollAfter && clientCoord > clientSize * (1 - threshold),\r\n        }\r\n      : {\r\n          up: canScrollBefore && clientCoord < clientSize * threshold,\r\n          down: canScrollAfter && clientCoord > clientSize * (1 - threshold),\r\n        };\r\n  }\r\n\r\n  if (\r\n    (overflow === \"auto\" || overflow === \"scroll\") &&\r\n    el !== document.body &&\r\n    el !== document.documentElement\r\n  ) {\r\n    const scrollSize = el[scrollSizeProp];\r\n    const offsetSize = el[offsetProp];\r\n    const scrollPos = el[scrollProp];\r\n\r\n    const canScrollBefore = scrollPos > 0;\r\n    const canScrollAfter = scrollPos < scrollSize - offsetSize;\r\n\r\n    return isX\r\n      ? {\r\n          left:\r\n            canScrollBefore && clientCoord < rectStart + offsetSize * threshold,\r\n          right:\r\n            canScrollAfter &&\r\n            clientCoord > rectStart + offsetSize * (1 - threshold),\r\n        }\r\n      : {\r\n          up:\r\n            canScrollBefore && clientCoord < rectStart + offsetSize * threshold,\r\n          down:\r\n            canScrollAfter &&\r\n            clientCoord > rectStart + offsetSize * (1 - threshold),\r\n        };\r\n  }\r\n\r\n  return isX ? { left: false, right: false } : { up: false, down: false };\r\n}\r\n\r\ntype Axis = \"x\" | \"y\";\r\n\r\nfunction scrollAxis<T>(\r\n  el: HTMLElement,\r\n  _e: PointerEvent | DragEvent,\r\n  state: DragState<T>,\r\n  options: {\r\n    axis: Axis;\r\n    direction: \"positive\" | \"negative\";\r\n  }\r\n) {\r\n  // Check if this is a stale call from a previous state\r\n  if (!isDragState(state) || !state.draggedNode) {\r\n    return; // State has been reset or is no longer in a drag state\r\n  }\r\n\r\n  state.preventEnter = true;\r\n\r\n  const isX = options.axis === \"x\";\r\n  const dirFactor = options.direction === \"positive\" ? 1 : -1;\r\n  const speed = 20;\r\n\r\n  const key = isX ? \"lastScrollDirectionX\" : \"lastScrollDirectionY\";\r\n  const idKey = isX ? \"frameIdX\" : \"frameIdY\";\r\n\r\n  // Cancel any existing animation first, regardless of direction\r\n  if (state[idKey] !== undefined) {\r\n    cancelAnimationFrame(state[idKey]!);\r\n    state[idKey] = undefined;\r\n  }\r\n\r\n  state[key] = options.direction;\r\n\r\n  const scrollLoop = () => {\r\n    // Check again if state is still valid\r\n    if (!isDragState(state) || !state.draggedNode) {\r\n      if (state[idKey] !== undefined) {\r\n        cancelAnimationFrame(state[idKey]!);\r\n        state[idKey] = undefined;\r\n      }\r\n      return;\r\n    }\r\n\r\n    const scrollProp = isX ? \"scrollLeft\" : \"scrollTop\";\r\n    const sizeProp = isX ? \"clientWidth\" : \"clientHeight\";\r\n    const scrollSizeProp = isX ? \"scrollWidth\" : \"scrollHeight\";\r\n\r\n    const scrollPos = el[scrollProp];\r\n    const clientSize = el[sizeProp];\r\n    const scrollSize = el[scrollSizeProp];\r\n\r\n    const canScroll =\r\n      dirFactor > 0 ? scrollPos + clientSize < scrollSize : scrollPos > 0;\r\n\r\n    if (!canScroll) {\r\n      state[idKey] = undefined;\r\n      state[key] = undefined;\r\n      return;\r\n    }\r\n\r\n    el[scrollProp] += speed * dirFactor;\r\n\r\n    if (isSynthDragState(state)) {\r\n      moveNode(state);\r\n    }\r\n\r\n    state[idKey] = requestAnimationFrame(scrollLoop);\r\n  };\r\n\r\n  state[idKey] = requestAnimationFrame(scrollLoop);\r\n}\r\n\r\nfunction isPointerInside(el: HTMLElement, x: number, y: number): boolean {\r\n  const rect = el.getBoundingClientRect();\r\n  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\r\n}\r\n\r\nfunction handleSynthScroll<T>(\r\n  coordinates: { x: number; y: number },\r\n  e: PointerEvent | DragEvent,\r\n  state: DragState<T>\r\n) {\r\n  // First check if this is a stale call from a previous state\r\n  if (!isDragState(state) || !state.draggedNode) {\r\n    return; // State has been reset or is no longer in a drag state\r\n  }\r\n\r\n  cancelSynthScroll(state);\r\n\r\n  const { x, y } = coordinates;\r\n\r\n  let scrolled = false;\r\n\r\n  const attemptScroll = (\r\n    axis: \"x\" | \"y\",\r\n    direction: \"positive\" | \"negative\",\r\n    container: HTMLElement\r\n  ) => {\r\n    scrollAxis(container, e, state, { axis, direction });\r\n    scrolled = true;\r\n  };\r\n\r\n  const checkAndScroll = (el: HTMLElement) => {\r\n    const style = window.getComputedStyle(el);\r\n    const rect = el.getBoundingClientRect();\r\n\r\n    const xResult = getScrollDirection(el, e, style, rect, {\r\n      axis: \"x\",\r\n      state,\r\n    });\r\n\r\n    const yResult = getScrollDirection(el, e, style, rect, { axis: \"y\" });\r\n\r\n    if (xResult.left || xResult.right) {\r\n      state.lastScrollContainerX = el;\r\n      attemptScroll(\"x\", xResult.right ? \"positive\" : \"negative\", el);\r\n    }\r\n\r\n    if (yResult.up || yResult.down) {\r\n      state.lastScrollContainerY = el;\r\n      attemptScroll(\"y\", yResult.down ? \"positive\" : \"negative\", el);\r\n    }\r\n  };\r\n\r\n  if (\r\n    state.lastScrollContainerX &&\r\n    isPointerInside(state.lastScrollContainerX, x, y)\r\n  ) {\r\n    checkAndScroll(state.lastScrollContainerX);\r\n  }\r\n\r\n  if (\r\n    !scrolled &&\r\n    state.lastScrollContainerY &&\r\n    isPointerInside(state.lastScrollContainerY, x, y)\r\n  ) {\r\n    checkAndScroll(state.lastScrollContainerY);\r\n  }\r\n\r\n  if (!scrolled) {\r\n    let el = document.elementFromPoint(x, y);\r\n    while (\r\n      el &&\r\n      !(scrolled && state.lastScrollContainerX && state.lastScrollContainerY)\r\n    ) {\r\n      if (el instanceof HTMLElement) {\r\n        checkAndScroll(el);\r\n      }\r\n      el = el.parentElement;\r\n    }\r\n  }\r\n\r\n  if (!scrolled) {\r\n    const root = document.scrollingElement;\r\n    if (root instanceof HTMLElement) {\r\n      checkAndScroll(root);\r\n    }\r\n  }\r\n\r\n  if (!scrolled) cancelSynthScroll(state);\r\n}\r\n\r\nexport function getElFromPoint<T>(coordinates: {\r\n  x: number;\r\n  y: number;\r\n}): NodeFromPoint<T> | ParentFromPoint<T> | undefined {\r\n  let target = document.elementFromPoint(coordinates.x, coordinates.y);\r\n\r\n  if (!isNode(target)) return;\r\n\r\n  let isParent;\r\n\r\n  let invalidEl = true;\r\n\r\n  while (target && invalidEl) {\r\n    if (nodes.has(target as Node) || parents.has(target as HTMLElement)) {\r\n      invalidEl = false;\r\n\r\n      isParent = parents.has(target as HTMLElement);\r\n\r\n      break;\r\n    }\r\n\r\n    target = target.parentNode as Node;\r\n  }\r\n\r\n  if (!isParent) {\r\n    const targetNodeData = nodes.get(target as Node);\r\n\r\n    if (!targetNodeData) return;\r\n\r\n    const targetParentData = parents.get(target.parentNode as Node);\r\n\r\n    if (!targetParentData) return;\r\n\r\n    return {\r\n      node: {\r\n        el: target as Node,\r\n        data: targetNodeData,\r\n      },\r\n      parent: {\r\n        el: target.parentNode as Node,\r\n        data: targetParentData as ParentData<T>,\r\n      },\r\n    };\r\n  } else {\r\n    const parentData = parents.get(target as HTMLElement);\r\n\r\n    if (!parentData) return;\r\n\r\n    return {\r\n      parent: {\r\n        el: target as HTMLElement,\r\n        data: parentData as ParentData<T>,\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Checks to see that a given element and its parent node is instance of\r\n * HTMLElement.\r\n *\r\n * @param {unknown} el - The element to check.\r\n *\r\n * @returns {boolean} - Whether or not provided element is of type Node.\r\n */\r\nexport function isNode(el: unknown): el is Node {\r\n  return el instanceof HTMLElement && el.parentNode instanceof HTMLElement;\r\n}\r\n\r\n/**\r\n * Takes a given el and event handlers, assigns them, and returns the used abort\r\n * controller.\r\n *\r\n * @param el - The element to add the event listeners to.\r\n * @param events - The events to add to the element.\r\n * @returns - The abort controller used for the event listeners.\r\n */\r\nexport function addEvents(\r\n  el: Document | ShadowRoot | Node | HTMLElement | Window,\r\n  events: EventHandlers | any\r\n): AbortController {\r\n  const abortController = new AbortController();\r\n\r\n  for (const eventName in events) {\r\n    const handler = events[eventName];\r\n\r\n    el.addEventListener(eventName, handler, {\r\n      signal: abortController.signal,\r\n      passive: false,\r\n      capture: eventName === \"focus\" || eventName === \"blur\",\r\n    });\r\n  }\r\n\r\n  return abortController;\r\n}\r\n","/**\r\n * Function to prevent default behavior of an event.\r\n *\r\n * @param {Event} e - The event to prevent default behavior of.\r\n */\r\nexport function pd(e: Event) {\r\n  e.preventDefault();\r\n}\r\n\r\n/**\r\n * Function to stop propagation of an event.\r\n *\r\n * @param {Event} e - The event to stop propagation of.\r\n */\r\nexport function sp(e: Event) {\r\n  e.stopPropagation();\r\n}\r\n\r\n/**\r\n * Function to get the bounding client rect of an element.\r\n *\r\n * @param {HTMLElement} el - The element to get the bounding client rect of.\r\n *\r\n * @returns {ClientRect} The bounding client rect of the element.\r\n */\r\nexport function rect(el: HTMLElement): ClientRect {\r\n  return el.getBoundingClientRect();\r\n}\r\n\r\n/**\r\n * Function to create an emitter.\r\n *\r\n * @returns {[Function, Function]} A tuple containing emit and on functions\r\n */\r\nexport function createEmitter<T>() {\r\n  const callbacks = new Map<string, Array<(data: T) => void>>();\r\n\r\n  const emit = function (eventName: string, data: T) {\r\n    if (!callbacks.get(eventName)) return;\r\n\r\n    callbacks.get(eventName)!.forEach((cb) => {\r\n      cb(data);\r\n    });\r\n  };\r\n\r\n  const on = function (eventName: string, callback: (data: T) => void) {\r\n    const cbs = callbacks.get(eventName) ?? [];\r\n\r\n    cbs.push(callback);\r\n\r\n    callbacks.set(eventName, cbs);\r\n  };\r\n\r\n  return [emit, on] as const;\r\n}\r\n\r\n/**\r\n * The emit and on functions for drag and drop.\r\n *\r\n * @type {[Function, Function]}\r\n */\r\nexport const [emit, on] = createEmitter();\r\n\r\n/**\r\n * A regular expression to test for a valid date string.\r\n *\r\n * @param x - A RegExp to compare.\r\n * @param y - A RegExp to compare.\r\n * @public\r\n */\r\nexport function eqRegExp(x: RegExp, y: RegExp): boolean {\r\n  return (\r\n    x.source === y.source &&\r\n    x.flags.split(\"\").sort().join(\"\") === y.flags.split(\"\").sort().join(\"\")\r\n  );\r\n}\r\n\r\n/**\r\n * Compare two values for equality, optionally at depth.\r\n *\r\n * @param valA - First value.\r\n * @param valB - Second value.\r\n * @param deep - If it will compare deeply if it's an object.\r\n * @param explicit - An array of keys to explicity check.\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\nexport function eq(\r\n  valA: unknown,\r\n  valB: unknown,\r\n  deep = true,\r\n  explicit: string[] = [\"__key\"]\r\n): boolean {\r\n  if (valA === valB) return true;\r\n\r\n  if (\r\n    typeof valB === \"object\" &&\r\n    typeof valA === \"object\" &&\r\n    valA !== null &&\r\n    valB !== null\r\n  ) {\r\n    if (valA instanceof Map) return false;\r\n    if (valA instanceof Set) return false;\r\n    if (valA instanceof Date && valB instanceof Date)\r\n      return valA.getTime() === valB.getTime();\r\n    if (valA instanceof RegExp && valB instanceof RegExp)\r\n      return eqRegExp(valA, valB);\r\n    if (valA === null || valB === null) return false;\r\n\r\n    const objA = valA as Record<string, unknown>;\r\n    const objB = valB as Record<string, unknown>;\r\n\r\n    if (Object.keys(objA).length !== Object.keys(objB).length) return false;\r\n\r\n    for (const k of explicit) {\r\n      if ((k in objA || k in objB) && objA[k] !== objB[k]) return false;\r\n    }\r\n\r\n    for (const key in objA) {\r\n      if (!(key in objB)) return false;\r\n      if (objA[key] !== objB[key] && !deep) return false;\r\n      if (deep && !eq(objA[key], objB[key], deep, explicit)) return false;\r\n    }\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Split a class name into an array of class names.\r\n *\r\n * @param className - The class name to split.\r\n *\r\n * @returns An array of class names.\r\n */\r\nexport function splitClass(className: string): Array<string> {\r\n  return className.split(\" \").filter((x) => x);\r\n}\r\n\r\nexport function getRealCoords(el: HTMLElement): {\r\n  top: number;\r\n  bottom: number;\r\n  left: number;\r\n  right: number;\r\n  height: number;\r\n  width: number;\r\n} {\r\n  const { top, bottom, left, right, height, width } =\r\n    el.getBoundingClientRect();\r\n\r\n  const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\r\n  const scrollTop = window.scrollY || document.documentElement.scrollTop;\r\n\r\n  return {\r\n    top: top + scrollTop,\r\n    bottom: bottom + scrollTop,\r\n    left: left + scrollLeft,\r\n    right: right + scrollLeft,\r\n    height,\r\n    width,\r\n  };\r\n}\r\n\r\nexport function eventCoordinates(data: DragEvent | PointerEvent) {\r\n  return { x: data.clientX, y: data.clientY };\r\n}\r\n","import type { SetupNodeData, Node } from \"../../types\";\r\nimport type { AnimationsConfig } from \"./types\";\r\nimport { state, parents, isDragState } from \"../../index\";\r\n\r\nexport function animations(animationsConfig: Partial<AnimationsConfig> = {}) {\r\n  const slideUp = [\r\n    {\r\n      transform: `translateY(${animationsConfig.yScale || 50}%)`,\r\n    },\r\n    {\r\n      transform: `translateY(${animationsConfig.yScale || 0}%)`,\r\n    },\r\n  ];\r\n\r\n  const slideDown = [\r\n    {\r\n      transform: `translateY(-${animationsConfig.yScale || 50}%)`,\r\n    },\r\n    {\r\n      transform: `translateY(${animationsConfig.yScale || 0}%)`,\r\n    },\r\n  ];\r\n\r\n  const slideLeft = [\r\n    {\r\n      transform: `translateX(${animationsConfig.xScale || 50}%)`,\r\n    },\r\n    {\r\n      transform: `translateX(${animationsConfig.xScale || 0}%)`,\r\n    },\r\n  ];\r\n\r\n  const slideRight = [\r\n    {\r\n      transform: `translateX(-${animationsConfig.xScale || 50}%)`,\r\n    },\r\n    {\r\n      transform: `translateX(${animationsConfig.xScale || 0}%)`,\r\n    },\r\n  ];\r\n  return (parent: HTMLElement) => {\r\n    const parentData = parents.get(parent);\r\n\r\n    if (!parentData) return;\r\n\r\n    return {\r\n      setup() {\r\n        if (document.head.querySelector(\"[data-drag-and-drop]\")) return;\r\n      },\r\n\r\n      setupNodeRemap<T>(data: SetupNodeData<T>) {\r\n        if (!isDragState(state)) return;\r\n\r\n        const duration = animationsConfig.duration || 150;\r\n\r\n        if (data.node.data.value === state.draggedNode.data.value) {\r\n          switch (state.incomingDirection) {\r\n            case \"below\":\r\n              animate(data.node.el, slideUp, duration);\r\n\r\n              break;\r\n            case \"above\":\r\n              animate(data.node.el, slideDown, duration);\r\n\r\n              break;\r\n            case \"left\":\r\n              animate(data.node.el, slideRight, duration);\r\n\r\n              break;\r\n            case \"right\":\r\n              animate(data.node.el, slideLeft, duration);\r\n\r\n              break;\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        if (\r\n          !state.affectedNodes\r\n            .map((x) => x.data.value)\r\n            .includes(data.node.data.value)\r\n        )\r\n          return;\r\n\r\n        const nodeRect = data.node.el.getBoundingClientRect();\r\n\r\n        const nodeIndex = state.affectedNodes.findIndex(\r\n          (x) => x.data.value === data.node.data.value\r\n        );\r\n\r\n        const draggedNodeIndex = state.draggedNode.data.index;\r\n\r\n        const ascendingDirection = draggedNodeIndex >= state.targetIndex;\r\n\r\n        let adjacentNode;\r\n\r\n        if (ascendingDirection) {\r\n          adjacentNode = state.affectedNodes[nodeIndex + 1]\r\n            ? state.affectedNodes[nodeIndex + 1]\r\n            : state.affectedNodes[nodeIndex - 1];\r\n        } else {\r\n          adjacentNode = state.affectedNodes[nodeIndex - 1]\r\n            ? state.affectedNodes[nodeIndex - 1]\r\n            : state.affectedNodes[nodeIndex + 1];\r\n        }\r\n\r\n        if (adjacentNode) {\r\n          const xDiff = Math.abs(\r\n            nodeRect.x - adjacentNode.el.getBoundingClientRect().x\r\n          );\r\n\r\n          const yDiff = Math.abs(\r\n            nodeRect.y - adjacentNode.el.getBoundingClientRect().y\r\n          );\r\n\r\n          if (xDiff > yDiff && ascendingDirection) {\r\n            animate(data.node.el, slideRight, duration);\r\n          } else if (xDiff > yDiff && !ascendingDirection) {\r\n            animate(data.node.el, slideLeft, duration);\r\n          }\r\n        } else {\r\n          switch (state.incomingDirection) {\r\n            case \"below\":\r\n              animate(data.node.el, slideDown, duration);\r\n\r\n              break;\r\n            case \"above\":\r\n              animate(data.node.el, slideUp, duration);\r\n\r\n              break;\r\n            case \"left\":\r\n              animate(data.node.el, slideLeft, duration);\r\n\r\n              break;\r\n            case \"right\":\r\n              animate(data.node.el, slideRight, duration);\r\n\r\n              break;\r\n          }\r\n        }\r\n      },\r\n    };\r\n  };\r\n}\r\n\r\nfunction animate(\r\n  node: Node,\r\n  animation: Keyframe[] | PropertyIndexedKeyframes,\r\n  duration: number\r\n) {\r\n  if (!state) return;\r\n\r\n  state.preventEnter = true;\r\n\r\n  node.animate(animation, {\r\n    duration: duration,\r\n    easing: \"ease-in-out\",\r\n  });\r\n\r\n  setTimeout(() => {\r\n    if (!state) return;\r\n\r\n    state.preventEnter = false;\r\n  }, duration);\r\n}\r\n","import type { InsertConfig } from \"../../types\";\r\nimport type {\r\n  DragState,\r\n  NodeDragEventData,\r\n  NodeRecord,\r\n  ParentEventData,\r\n  PointeroverParentEvent,\r\n  ParentRecord,\r\n  SynthDragState,\r\n  InsertEvent,\r\n  BaseDragState,\r\n  InsertState,\r\n  Coordinates,\r\n  Node,\r\n} from \"../../types\";\r\n\r\nimport {\r\n  parents,\r\n  parentValues,\r\n  setParentValues,\r\n  state,\r\n  addParentClass,\r\n  isDragState,\r\n  isSynthDragState,\r\n  removeClass,\r\n  addEvents,\r\n  remapNodes,\r\n  nodes,\r\n} from \"../../index\";\r\n\r\nimport { eq, pd, eventCoordinates } from \"../../utils\";\r\n\r\nexport const insertState: InsertState<unknown> = {\r\n  draggedOverNodes: [],\r\n  draggedOverParent: null,\r\n  targetIndex: 0,\r\n  ascending: false,\r\n  insertPoint: null,\r\n  dragging: false,\r\n};\r\n\r\nlet documentController: AbortController | undefined;\r\n\r\n// WIP: This is a work in progress and not yet fully functional\r\nexport function insert<T>(insertConfig: InsertConfig<T>) {\r\n  return (parent: HTMLElement) => {\r\n    const parentData = parents.get(parent);\r\n\r\n    if (!parentData) return;\r\n\r\n    const insertParentConfig = {\r\n      ...parentData.config,\r\n      insertConfig,\r\n    };\r\n\r\n    return {\r\n      teardown() {\r\n        if (parentData.abortControllers.root) {\r\n          parentData.abortControllers.root.abort();\r\n        }\r\n      },\r\n      setup() {\r\n        insertParentConfig.handleNodeDragover =\r\n          insertConfig.handleNodeDragover || handleNodeDragover;\r\n\r\n        insertParentConfig.handleParentPointerover =\r\n          insertConfig.handleParentPointerover || handleParentPointerover;\r\n\r\n        insertParentConfig.handleNodePointerover =\r\n          insertConfig.handleNodePointerover || handleParentPointerover;\r\n\r\n        insertParentConfig.handleParentDragover =\r\n          insertConfig.handleParentDragover || handleParentDragover;\r\n\r\n        const originalHandleend = insertParentConfig.handleEnd;\r\n\r\n        insertParentConfig.handleEnd = (\r\n          state: DragState<T> | SynthDragState<T>\r\n        ) => {\r\n          handleEnd(state);\r\n\r\n          originalHandleend(state);\r\n        };\r\n\r\n        parentData.on(\"dragStarted\", () => {\r\n          documentController = addEvents(document, {\r\n            dragover: checkPosition,\r\n            pointermove: checkPosition,\r\n          });\r\n        });\r\n\r\n        parentData.on(\"dragEnded\", () => {\r\n          documentController?.abort();\r\n        });\r\n\r\n        parentData.config = insertParentConfig;\r\n\r\n        state.on(\"dragStarted\", () => {\r\n          defineRanges(parent);\r\n        });\r\n\r\n        state.on(\"scrollStarted\", () => {\r\n          if (insertState.insertPoint)\r\n            insertState.insertPoint.el.style.display = \"none\";\r\n        });\r\n\r\n        state.on(\"scrollEnded\", () => {\r\n          defineRanges(parent);\r\n        });\r\n\r\n        const firstScrollableParent = findFirstOverflowingParent(parent);\r\n\r\n        if (firstScrollableParent) {\r\n          firstScrollableParent.addEventListener(\r\n            \"scroll\",\r\n            defineRanges.bind(null, parent)\r\n          );\r\n        }\r\n\r\n        window.addEventListener(\"resize\", defineRanges.bind(null, parent));\r\n      },\r\n    };\r\n  };\r\n}\r\n\r\nfunction findFirstOverflowingParent(element: HTMLElement): HTMLElement | null {\r\n  let parent = element.parentElement;\r\n\r\n  while (parent) {\r\n    const { overflow, overflowY, overflowX } = getComputedStyle(parent);\r\n\r\n    // Check if the overflow property is set to scroll, auto, or hidden (anything other than visible)\r\n    const isOverflowSet =\r\n      overflow !== \"visible\" ||\r\n      overflowY !== \"visible\" ||\r\n      overflowX !== \"visible\";\r\n\r\n    // Check if there is actual overflow (scrolling)\r\n    const isOverflowing =\r\n      parent.scrollHeight > parent.clientHeight ||\r\n      parent.scrollWidth > parent.clientWidth;\r\n    const hasScrollPosition = parent.scrollTop > 0 || parent.scrollLeft > 0;\r\n\r\n    if (isOverflowSet && (isOverflowing || hasScrollPosition)) {\r\n      return parent;\r\n    }\r\n\r\n    parent = parent.parentElement;\r\n  }\r\n\r\n  return null; // No overflowing parent found\r\n}\r\n\r\nfunction checkPosition(e: DragEvent | PointerEvent) {\r\n  if (!isDragState(state)) return;\r\n\r\n  const el = document.elementFromPoint(e.clientX, e.clientY);\r\n\r\n  // 1. If the element is not an HTMLElement or is the insert point itself, do nothing.\r\n  if (!(el instanceof HTMLElement) || el === insertState.insertPoint?.el) {\r\n    return;\r\n  }\r\n\r\n  // 2. Traverse up the DOM from the element under the cursor\r\n  //    to see if any ancestor is a registered parent.\r\n  let isWithinAParent = false;\r\n  let current: HTMLElement | null = el;\r\n  while (current) {\r\n    if (nodes.has(current as Node) || parents.has(current)) {\r\n      isWithinAParent = true;\r\n      break; // Found a registered parent ancestor\r\n    }\r\n    if (current === document.body) break; // Stop if we reach the body\r\n    current = current.parentElement;\r\n  }\r\n\r\n  // 3. If the cursor is NOT within any registered parent...\r\n  if (!isWithinAParent) {\r\n    // Hide the insert point if it exists\r\n    if (insertState.insertPoint) {\r\n      insertState.insertPoint.el.style.display = \"none\";\r\n    }\r\n\r\n    // Remove drop zone class if a parent was previously being dragged over\r\n    if (insertState.draggedOverParent) {\r\n      removeClass(\r\n        [insertState.draggedOverParent.el],\r\n        insertState.draggedOverParent.data.config.dropZoneClass\r\n      );\r\n    }\r\n\r\n    // Reset insert state related to dragged over elements\r\n    insertState.draggedOverNodes = [];\r\n    insertState.draggedOverParent = null;\r\n\r\n    // Reset current parent in the main state back to the initial one\r\n    state.currentParent = state.initialParent;\r\n  }\r\n  // 4. If the cursor IS within a registered parent, do nothing in this function.\r\n  // Other event handlers will manage the insertion point positioning.\r\n}\r\n\r\ninterface Range {\r\n  x: [number, number];\r\n  y: [number, number];\r\n  vertical: boolean;\r\n}\r\n\r\nfunction createVerticalRange(\r\n  nodeCoords: Coordinates,\r\n  otherCoords: Coordinates | undefined,\r\n  isAscending: boolean\r\n): Range {\r\n  const center = nodeCoords.top + nodeCoords.height / 2;\r\n\r\n  if (!otherCoords) {\r\n    const offset = nodeCoords.height / 2 + 10;\r\n    return {\r\n      y: isAscending ? [center, center + offset] : [center - offset, center],\r\n      x: [nodeCoords.left, nodeCoords.right],\r\n      vertical: true,\r\n    };\r\n  }\r\n\r\n  const otherEdge = isAscending ? otherCoords.top : otherCoords.bottom;\r\n  const nodeEdge = isAscending ? nodeCoords.bottom : nodeCoords.top;\r\n\r\n  let midpoint: number;\r\n  let range: [number, number];\r\n\r\n  if (isAscending) {\r\n    // Midpoint between current node's bottom and next node's top\r\n    midpoint = nodeEdge + (otherEdge - nodeEdge) / 2; // nodeCoords.bottom + (otherCoords.top - nodeCoords.bottom) / 2\r\n    range = [center, midpoint]; // Range from node center down to midpoint\r\n  } else {\r\n    // Midpoint between previous node's bottom and current node's top\r\n    midpoint = otherEdge + (nodeEdge - otherEdge) / 2; // otherCoords.bottom + (nodeCoords.top - otherCoords.bottom) / 2\r\n    range = [midpoint, center]; // Range from midpoint down to node center\r\n  }\r\n\r\n  return {\r\n    y: range,\r\n    x: [nodeCoords.left, nodeCoords.right],\r\n    vertical: true,\r\n  };\r\n}\r\n\r\nfunction createHorizontalRange(\r\n  nodeCoords: Coordinates,\r\n  otherCoords: Coordinates | undefined,\r\n  isAscending: boolean,\r\n  lastInRow = false\r\n): Range {\r\n  const center = nodeCoords.left + nodeCoords.width / 2;\r\n\r\n  if (!otherCoords) {\r\n    if (isAscending) {\r\n      return {\r\n        x: [center, center + nodeCoords.width],\r\n        y: [nodeCoords.top, nodeCoords.bottom],\r\n        vertical: false,\r\n      };\r\n    } else {\r\n      return {\r\n        x: [nodeCoords.left - 10, center],\r\n        y: [nodeCoords.top, nodeCoords.bottom],\r\n        vertical: false,\r\n      };\r\n    }\r\n  }\r\n\r\n  if (isAscending && lastInRow) {\r\n    return {\r\n      x: [center, nodeCoords.right + 10],\r\n      y: [nodeCoords.top, nodeCoords.bottom],\r\n      vertical: false,\r\n    };\r\n  }\r\n\r\n  if (isAscending) {\r\n    const nextNodeCenter = otherCoords.left + otherCoords.width / 2;\r\n    return {\r\n      x: [center, center + Math.abs(center - nextNodeCenter) / 2],\r\n      y: [nodeCoords.top, nodeCoords.bottom],\r\n      vertical: false,\r\n    };\r\n  } else {\r\n    return {\r\n      x: [\r\n        otherCoords.right + Math.abs(otherCoords.right - nodeCoords.left) / 2,\r\n        center,\r\n      ],\r\n      y: [nodeCoords.top, nodeCoords.bottom],\r\n      vertical: false,\r\n    };\r\n  }\r\n}\r\n\r\nfunction getRealCoords(el: HTMLElement): Coordinates {\r\n  const { top, bottom, left, right, height, width } =\r\n    el.getBoundingClientRect();\r\n\r\n  const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\r\n  const scrollTop = window.scrollY || document.documentElement.scrollTop;\r\n\r\n  return {\r\n    top: top + scrollTop,\r\n    bottom: bottom + scrollTop,\r\n    left: left + scrollLeft,\r\n    right: right + scrollLeft,\r\n    height,\r\n    width,\r\n  };\r\n}\r\n\r\nfunction defineRanges(parent: HTMLElement) {\r\n  if (!isDragState(state) && !isSynthDragState(state)) return;\r\n\r\n  const parentData = parents.get(parent);\r\n  if (!parentData) return;\r\n\r\n  const enabledNodes = parentData.enabledNodes;\r\n\r\n  enabledNodes.forEach((node, index) => {\r\n    node.data.range = {};\r\n\r\n    const prevNode = enabledNodes[index - 1];\r\n    const nextNode = enabledNodes[index + 1];\r\n    const nodeCoords = getRealCoords(node.el);\r\n    const prevNodeCoords = prevNode ? getRealCoords(prevNode.el) : undefined;\r\n    const nextNodeCoords = nextNode ? getRealCoords(nextNode.el) : undefined;\r\n\r\n    const aboveOrBelowPrevious =\r\n      prevNodeCoords &&\r\n      (nodeCoords.top > prevNodeCoords.bottom ||\r\n        nodeCoords.bottom < prevNodeCoords.top);\r\n\r\n    const aboveOrBelowAfter =\r\n      nextNodeCoords &&\r\n      (nodeCoords.top > nextNodeCoords.bottom ||\r\n        nodeCoords.bottom < nextNodeCoords.top);\r\n\r\n    const fullishWidth =\r\n      parent.getBoundingClientRect().width * 0.8 < nodeCoords.width;\r\n\r\n    if (fullishWidth) {\r\n      node.data.range.ascending = createVerticalRange(\r\n        nodeCoords,\r\n        nextNodeCoords,\r\n        true\r\n      );\r\n      node.data.range.descending = createVerticalRange(\r\n        nodeCoords,\r\n        prevNodeCoords,\r\n        false\r\n      );\r\n    } else if (aboveOrBelowAfter && !aboveOrBelowPrevious) {\r\n      node.data.range.ascending = createHorizontalRange(\r\n        nodeCoords,\r\n        nextNodeCoords,\r\n        true,\r\n        true\r\n      );\r\n      node.data.range.descending = createHorizontalRange(\r\n        nodeCoords,\r\n        prevNodeCoords,\r\n        false\r\n      );\r\n    } else if (!aboveOrBelowPrevious && !aboveOrBelowAfter) {\r\n      node.data.range.ascending = createHorizontalRange(\r\n        nodeCoords,\r\n        nextNodeCoords,\r\n        true\r\n      );\r\n      node.data.range.descending = createHorizontalRange(\r\n        nodeCoords,\r\n        prevNodeCoords,\r\n        false\r\n      );\r\n    } else if (aboveOrBelowPrevious && !nextNodeCoords) {\r\n      node.data.range.ascending = createHorizontalRange(\r\n        nodeCoords,\r\n        undefined,\r\n        true\r\n      );\r\n    } else if (aboveOrBelowPrevious && !aboveOrBelowAfter) {\r\n      node.data.range.ascending = createHorizontalRange(\r\n        nodeCoords,\r\n        nextNodeCoords,\r\n        true\r\n      );\r\n      node.data.range.descending = createHorizontalRange(\r\n        nodeCoords,\r\n        undefined,\r\n        false\r\n      );\r\n    }\r\n  });\r\n}\r\n\r\nexport function handleNodeDragover<T>(data: NodeDragEventData<T>) {\r\n  const config = data.targetData.parent.data.config;\r\n\r\n  if (!config.nativeDrag) return;\r\n\r\n  data.e.preventDefault();\r\n}\r\n\r\nfunction processParentDragEvent<T>(\r\n  e: DragEvent | PointerEvent,\r\n  targetData: ParentEventData<T>[\"targetData\"],\r\n  state: DragState<T>,\r\n  nativeDrag = false\r\n) {\r\n  pd(e);\r\n\r\n  if (nativeDrag && e instanceof PointerEvent) return;\r\n\r\n  const { x, y } = eventCoordinates(e);\r\n\r\n  // Calculate global coordinates\r\n  const clientX = x;\r\n  const clientY = y;\r\n\r\n  const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\r\n  const scrollTop = window.scrollY || document.documentElement.scrollTop;\r\n\r\n  state.coordinates.x = clientX + scrollLeft;\r\n  state.coordinates.y = clientY + scrollTop;\r\n\r\n  const nestedParent = targetData.parent.data.nestedParent;\r\n\r\n  let realTargetParent = targetData.parent;\r\n\r\n  if (nestedParent) {\r\n    const rect = nestedParent.el.getBoundingClientRect();\r\n\r\n    if (state.coordinates.y > rect.top && state.coordinates.y < rect.bottom)\r\n      realTargetParent = nestedParent;\r\n  }\r\n\r\n  if (realTargetParent.el === state.currentParent?.el) {\r\n    moveBetween(realTargetParent, state);\r\n  } else {\r\n    moveOutside(realTargetParent, state);\r\n  }\r\n\r\n  state.currentParent = realTargetParent;\r\n}\r\n\r\nexport function handleParentDragover<T>(\r\n  data: ParentEventData<T>,\r\n  state: DragState<T>\r\n) {\r\n  processParentDragEvent(data.e as DragEvent, data.targetData, state, true);\r\n}\r\n\r\nexport function handleParentPointerover<T>(data: PointeroverParentEvent<T>) {\r\n  const { detail } = data;\r\n\r\n  const { state, targetData } = detail;\r\n\r\n  if (state.scrolling) return;\r\n\r\n  processParentDragEvent(detail.e, targetData, state);\r\n}\r\n\r\nexport function moveBetween<T>(data: ParentRecord<T>, state: DragState<T>) {\r\n  if (data.data.config.sortable === false) return;\r\n\r\n  if (\r\n    data.el === insertState.draggedOverParent?.el &&\r\n    insertState.draggedOverParent.data.getValues(data.el).length === 0\r\n  ) {\r\n    return;\r\n  } else if (insertState.draggedOverParent?.el) {\r\n    removeClass(\r\n      [insertState.draggedOverParent.el],\r\n      insertState.draggedOverParent.data.config.dropZoneClass\r\n    );\r\n    insertState.draggedOverParent = null;\r\n  }\r\n\r\n  const foundRange = findClosest(data.data.enabledNodes, state);\r\n\r\n  if (!foundRange) return;\r\n\r\n  const key = foundRange[1] as \"ascending\" | \"descending\";\r\n\r\n  if (foundRange) {\r\n    const position = foundRange[0].data.range\r\n      ? foundRange[0].data.range[key]\r\n      : undefined;\r\n\r\n    if (position)\r\n      positionInsertPoint(\r\n        data,\r\n        position,\r\n        foundRange[1] === \"ascending\",\r\n        foundRange[0],\r\n        insertState as InsertState<T>\r\n      );\r\n  }\r\n}\r\n\r\nfunction moveOutside<T>(data: ParentRecord<T>, state: DragState<T>) {\r\n  if (data.el === state.currentParent.el) return false;\r\n\r\n  const targetConfig = data.data.config;\r\n\r\n  if (state.draggedNode.el.contains(data.el)) return false;\r\n\r\n  if (targetConfig.dropZone === false) return;\r\n\r\n  const initialParentConfig = state.initialParent.data.config;\r\n\r\n  if (targetConfig.accepts) {\r\n    return targetConfig.accepts(\r\n      data,\r\n      state.initialParent,\r\n      state.currentParent,\r\n      state\r\n    );\r\n  } else if (\r\n    !targetConfig.group ||\r\n    targetConfig.group !== initialParentConfig.group\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  const values = data.data.getValues(data.el);\r\n\r\n  if (!values.length) {\r\n    addParentClass([data.el], targetConfig.dropZoneClass);\r\n\r\n    insertState.draggedOverParent = data as ParentRecord<unknown>;\r\n\r\n    const insertPoint = insertState.insertPoint;\r\n\r\n    if (insertPoint) insertPoint.el.style.display = \"none\";\r\n  } else {\r\n    removeClass([state.currentParent.el], targetConfig.dropZoneClass);\r\n\r\n    const enabledNodes = data.data.enabledNodes;\r\n\r\n    const foundRange = findClosest(enabledNodes, state);\r\n\r\n    if (!foundRange) return;\r\n\r\n    const key = foundRange[1] as \"ascending\" | \"descending\";\r\n\r\n    if (foundRange) {\r\n      const position = foundRange[0].data.range\r\n        ? foundRange[0].data.range[key]\r\n        : undefined;\r\n\r\n      if (position)\r\n        positionInsertPoint(\r\n          data,\r\n          position,\r\n          foundRange[1] === \"ascending\",\r\n          foundRange[0],\r\n          insertState as InsertState<T>\r\n        );\r\n    }\r\n  }\r\n}\r\n\r\nfunction findClosest<T>(enabledNodes: NodeRecord<T>[], state: DragState<T>) {\r\n  let foundRange: [NodeRecord<T>, string] | null = null;\r\n\r\n  for (let x = 0; x < enabledNodes.length; x++) {\r\n    if (!state || !enabledNodes[x].data.range) continue;\r\n\r\n    if (enabledNodes[x].data.range!.ascending) {\r\n      if (\r\n        state.coordinates.y > enabledNodes[x].data.range!.ascending!.y[0] &&\r\n        state.coordinates.y < enabledNodes[x].data.range!.ascending!.y[1] &&\r\n        state.coordinates.x > enabledNodes[x].data.range!.ascending!.x[0] &&\r\n        state.coordinates.x < enabledNodes[x].data.range!.ascending!.x[1]\r\n      ) {\r\n        foundRange = [enabledNodes[x], \"ascending\"];\r\n\r\n        return foundRange;\r\n      }\r\n    }\r\n\r\n    if (enabledNodes[x].data.range!.descending) {\r\n      if (\r\n        state.coordinates.y > enabledNodes[x].data.range!.descending!.y[0] &&\r\n        state.coordinates.y < enabledNodes[x].data.range!.descending!.y[1] &&\r\n        state.coordinates.x > enabledNodes[x].data.range!.descending!.x[0] &&\r\n        state.coordinates.x < enabledNodes[x].data.range!.descending!.x[1]\r\n      ) {\r\n        foundRange = [enabledNodes[x], \"descending\"];\r\n\r\n        return foundRange;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction createInsertPoint<T>(\r\n  parent: ParentRecord<T>,\r\n  insertState: InsertState<T>\r\n) {\r\n  const insertPoint = parent.data.config.insertConfig?.insertPoint({\r\n    el: parent.el,\r\n    data: parent.data,\r\n  });\r\n\r\n  if (!insertPoint)\r\n    throw new Error(\"Insert point not found\", { cause: parent });\r\n\r\n  insertState.insertPoint = {\r\n    parent,\r\n    el: insertPoint,\r\n  };\r\n\r\n  document.body.appendChild(insertPoint);\r\n\r\n  Object.assign(insertPoint.style, {\r\n    position: \"absolute\",\r\n    display: \"none\",\r\n  });\r\n}\r\n\r\nfunction removeInsertPoint<T>(insertState: InsertState<T>) {\r\n  if (insertState.insertPoint?.el) insertState.insertPoint.el.remove();\r\n\r\n  insertState.insertPoint = null;\r\n}\r\n\r\nfunction positionInsertPoint<T>(\r\n  parent: ParentRecord<T>,\r\n  position: { x: number[]; y: number[]; vertical: boolean },\r\n  ascending: boolean,\r\n  node: NodeRecord<T>,\r\n  insertState: InsertState<T>\r\n) {\r\n  if (insertState.insertPoint?.el !== parent.el) {\r\n    removeInsertPoint(insertState);\r\n\r\n    createInsertPoint(parent, insertState);\r\n  }\r\n\r\n  insertState.draggedOverNodes = [node];\r\n\r\n  if (!insertState.insertPoint) return;\r\n\r\n  insertState.insertPoint.el.style.display = \"block\";\r\n\r\n  if (position.vertical) {\r\n    const insertPointHeight =\r\n      insertState.insertPoint.el.getBoundingClientRect().height;\r\n    const targetY = position.y[ascending ? 1 : 0];\r\n    const topPosition = targetY - insertPointHeight / 2;\r\n\r\n    Object.assign(insertState.insertPoint.el.style, {\r\n      top: `${topPosition}px`,\r\n      left: `${position.x[0]}px`,\r\n      right: `${position.x[1]}px`,\r\n      width: `${position.x[1] - position.x[0]}px`,\r\n    });\r\n  } else {\r\n    const leftPosition =\r\n      position.x[ascending ? 1 : 0] -\r\n      insertState.insertPoint.el.getBoundingClientRect().width / 2;\r\n    insertState.insertPoint.el.style.left = `${leftPosition}px`;\r\n\r\n    Object.assign(insertState.insertPoint.el.style, {\r\n      top: `${position.y[0]}px`,\r\n      bottom: `${position.y[1]}px`,\r\n      height: `${position.y[1] - position.y[0]}px`,\r\n    });\r\n  }\r\n\r\n  insertState.targetIndex = node.data.index;\r\n\r\n  insertState.ascending = ascending;\r\n}\r\n\r\nexport function handleParentDrop<T>(_data: NodeDragEventData<T>) {}\r\n\r\n/**\r\n * Performs the actual insertion of the dragged nodes into the target parent.\r\n *\r\n * @param state - The current drag state.\r\n */\r\nexport function handleEnd<T>(\r\n  state: DragState<T> | SynthDragState<T> | BaseDragState<T>\r\n) {\r\n  if (!isDragState(state) && !isSynthDragState(state)) return;\r\n\r\n  const insertPoint = insertState.insertPoint;\r\n\r\n  if (!insertState.draggedOverParent) {\r\n    const draggedParentValues = parentValues(\r\n      state.initialParent.el,\r\n      state.initialParent.data\r\n    );\r\n\r\n    const transferred = state.initialParent.el !== state.currentParent.el;\r\n\r\n    remapNodes(state.initialParent.el);\r\n\r\n    const draggedValues = state.draggedNodes.map((node) => node.data.value);\r\n\r\n    const enabledNodes = [...state.initialParent.data.enabledNodes];\r\n\r\n    const originalIndex = state.draggedNodes[0].data.index;\r\n\r\n    const targetIndex = insertState.targetIndex;\r\n\r\n    if (\r\n      !transferred &&\r\n      insertState.draggedOverNodes[0] &&\r\n      insertState.draggedOverNodes[0].el !== state.draggedNodes[0].el\r\n    ) {\r\n      const newParentValues = [\r\n        ...draggedParentValues.filter(\r\n          (x) => !draggedValues.some((y) => eq(x, y))\r\n        ),\r\n      ];\r\n\r\n      let index = insertState.draggedOverNodes[0].data.index;\r\n\r\n      if (\r\n        insertState.targetIndex > state.draggedNodes[0].data.index &&\r\n        !insertState.ascending\r\n      ) {\r\n        index--;\r\n      } else if (\r\n        insertState.targetIndex < state.draggedNodes[0].data.index &&\r\n        insertState.ascending\r\n      ) {\r\n        index++;\r\n      }\r\n\r\n      newParentValues.splice(index, 0, ...draggedValues);\r\n\r\n      setParentValues(state.initialParent.el, state.initialParent.data, [\r\n        ...newParentValues,\r\n      ]);\r\n\r\n      if (state.initialParent.data.config.onSort) {\r\n        const sortEventData = {\r\n          parent: {\r\n            el: state.initialParent.el,\r\n            data: state.initialParent.data,\r\n          } as ParentRecord<unknown>,\r\n          previousValues: [...draggedParentValues],\r\n          previousNodes: [...enabledNodes],\r\n          nodes: [...state.initialParent.data.enabledNodes],\r\n          values: [...newParentValues],\r\n          draggedNodes: state.draggedNodes,\r\n          targetNodes: insertState.draggedOverNodes,\r\n          previousPosition: originalIndex,\r\n          position: index,\r\n          state: state as DragState<unknown>,\r\n        };\r\n\r\n        state.initialParent.data.config.onSort(sortEventData);\r\n      }\r\n    } else if (transferred && insertState.draggedOverNodes.length) {\r\n      const draggedParentValues = parentValues(\r\n        state.initialParent.el,\r\n        state.initialParent.data\r\n      );\r\n\r\n      // For the time being, we will not be remoing the value of the original dragged parent.\r\n      let index = insertState.draggedOverNodes[0].data.index || 0;\r\n\r\n      if (insertState.ascending) index++;\r\n\r\n      const insertValues = state.initialParent.data.config.insertConfig\r\n        ?.dynamicValues\r\n        ? state.initialParent.data.config.insertConfig.dynamicValues({\r\n            sourceParent: state.initialParent,\r\n            targetParent: state.currentParent,\r\n            draggedNodes: state.draggedNodes,\r\n            targetNodes: insertState.draggedOverNodes as NodeRecord<T>[],\r\n            targetIndex: index,\r\n          })\r\n        : draggedValues;\r\n\r\n      const newParentValues = [\r\n        ...draggedParentValues.filter(\r\n          (x) => !draggedValues.some((y) => eq(x, y))\r\n        ),\r\n      ];\r\n\r\n      if (state.currentParent.el.contains(state.initialParent.el)) {\r\n        // Update initial parent values first\r\n        setParentValues(state.initialParent.el, state.initialParent.data, [\r\n          ...newParentValues,\r\n        ]);\r\n\r\n        // Now get the target parent values.\r\n        const targetParentValues = parentValues(\r\n          state.currentParent.el,\r\n          state.currentParent.data\r\n        );\r\n\r\n        targetParentValues.splice(index, 0, ...insertValues);\r\n\r\n        setParentValues(state.currentParent.el, state.currentParent.data, [\r\n          ...targetParentValues,\r\n        ]);\r\n      } else {\r\n        setParentValues(state.initialParent.el, state.initialParent.data, [\r\n          ...newParentValues,\r\n        ]);\r\n\r\n        const targetParentValues = parentValues(\r\n          state.currentParent.el,\r\n          state.currentParent.data\r\n        );\r\n\r\n        targetParentValues.splice(index, 0, ...insertValues);\r\n\r\n        setParentValues(state.currentParent.el, state.currentParent.data, [\r\n          ...targetParentValues,\r\n        ]);\r\n      }\r\n\r\n      const data = {\r\n        sourceParent: state.initialParent,\r\n        targetParent: state.currentParent,\r\n        initialParent: state.initialParent,\r\n        draggedNodes: state.draggedNodes,\r\n        targetIndex,\r\n        targetNodes: insertState.draggedOverNodes as NodeRecord<T>[],\r\n        state,\r\n      };\r\n\r\n      if (state.initialParent.data.config.onTransfer)\r\n        state.initialParent.data.config.onTransfer(data);\r\n      if (state.currentParent.data.config.onTransfer)\r\n        state.currentParent.data.config.onTransfer(data);\r\n    }\r\n  } else if (insertState.draggedOverParent) {\r\n    if (state.currentParent.el.contains(state.initialParent.el)) {\r\n      const draggedParentValues = parentValues(\r\n        state.initialParent.el,\r\n        state.initialParent.data\r\n      );\r\n\r\n      const newParentValues = [\r\n        ...draggedParentValues.filter(\r\n          (x) => !draggedValues.some((y) => eq(x, y))\r\n        ),\r\n      ];\r\n\r\n      setParentValues(state.initialParent.el, state.initialParent.data, [\r\n        ...newParentValues,\r\n      ]);\r\n\r\n      const draggedOverParentValues = parentValues(\r\n        insertState.draggedOverParent.el,\r\n        insertState.draggedOverParent.data\r\n      );\r\n\r\n      const draggedValues = state.draggedNodes.map((node) => node.data.value);\r\n\r\n      const insertValues = state.initialParent.data.config.insertConfig\r\n        ?.dynamicValues\r\n        ? state.initialParent.data.config.insertConfig.dynamicValues({\r\n            sourceParent: state.initialParent,\r\n            targetParent: state.currentParent,\r\n            draggedNodes: state.draggedNodes,\r\n            targetNodes: insertState.draggedOverNodes as NodeRecord<T>[],\r\n          })\r\n        : draggedValues;\r\n\r\n      draggedOverParentValues.push(...insertValues);\r\n\r\n      setParentValues(\r\n        insertState.draggedOverParent.el,\r\n        insertState.draggedOverParent.data,\r\n        [...draggedOverParentValues]\r\n      );\r\n    } else {\r\n      const draggedValues = state.draggedNodes.map((node) => node.data.value);\r\n\r\n      const draggedOverParentValues = parentValues(\r\n        insertState.draggedOverParent.el,\r\n        insertState.draggedOverParent.data\r\n      );\r\n\r\n      const insertValues = state.initialParent.data.config.insertConfig\r\n        ?.dynamicValues\r\n        ? state.initialParent.data.config.insertConfig.dynamicValues({\r\n            sourceParent: state.initialParent,\r\n            targetParent: state.currentParent,\r\n            draggedNodes: state.draggedNodes,\r\n            targetNodes: insertState.draggedOverNodes as NodeRecord<T>[],\r\n          })\r\n        : draggedValues;\r\n\r\n      draggedOverParentValues.push(...insertValues);\r\n\r\n      setParentValues(\r\n        insertState.draggedOverParent.el,\r\n        insertState.draggedOverParent.data,\r\n        [...draggedOverParentValues]\r\n      );\r\n\r\n      const draggedParentValues = parentValues(\r\n        state.initialParent.el,\r\n        state.initialParent.data\r\n      );\r\n\r\n      const newParentValues = [\r\n        ...draggedParentValues.filter(\r\n          (x) => !draggedValues.some((y) => eq(x, y))\r\n        ),\r\n      ];\r\n\r\n      setParentValues(state.initialParent.el, state.initialParent.data, [\r\n        ...newParentValues,\r\n      ]);\r\n    }\r\n\r\n    const data: InsertEvent<T> = {\r\n      sourceParent: state.initialParent,\r\n      targetParent: state.currentParent,\r\n      draggedNodes: state.draggedNodes,\r\n      targetNodes: insertState.draggedOverNodes as NodeRecord<T>[],\r\n      state,\r\n    };\r\n\r\n    if (state.initialParent.data.config.insertConfig?.insertEvent)\r\n      state.initialParent.data.config.insertConfig.insertEvent(data);\r\n    if (state.currentParent.data.config.insertConfig?.insertEvent)\r\n      state.currentParent.data.config.insertConfig.insertEvent(data);\r\n\r\n    removeClass(\r\n      [insertState.draggedOverParent.el],\r\n      insertState.draggedOverParent.data.config.dropZoneClass\r\n    );\r\n  }\r\n\r\n  if (insertPoint) insertPoint.el.style.display = \"none\";\r\n\r\n  const dropZoneClass = isSynthDragState(state)\r\n    ? state.initialParent.data.config.synthDropZoneClass\r\n    : state.initialParent.data.config.dropZoneClass;\r\n\r\n  removeClass(\r\n    insertState.draggedOverNodes.map((node) => node.el),\r\n    dropZoneClass\r\n  );\r\n\r\n  const dragPlaceholderClass =\r\n    state.initialParent.data.config.dragPlaceholderClass;\r\n\r\n  removeClass(\r\n    state.draggedNodes.map((node) => node.el),\r\n    dragPlaceholderClass\r\n  );\r\n\r\n  insertState.draggedOverNodes = [];\r\n\r\n  insertState.draggedOverParent = null;\r\n}\r\n","import type {\r\n  DropSwapConfig,\r\n  NodeDragEventData,\r\n  DragState,\r\n  SynthDragState,\r\n  NodeRecord,\r\n  PointeroverNodeEvent,\r\n  ParentDragEventData,\r\n  PointeroverParentEvent,\r\n  DropSwapState,\r\n  ParentRecord,\r\n  BaseDragState,\r\n} from \"../../types\";\r\nimport {\r\n  parents,\r\n  parentValues,\r\n  setParentValues,\r\n  addNodeClass,\r\n  isSynthDragState,\r\n  removeClass,\r\n  addClass,\r\n  state,\r\n  addEvents,\r\n  isDragState,\r\n} from \"../../index\";\r\n\r\nexport const dropSwapState: DropSwapState<unknown> = {\r\n  draggedOverNodes: Array<NodeRecord<unknown>>(),\r\n  initialDraggedIndex: undefined,\r\n  transferred: false,\r\n  dragging: false,\r\n};\r\n\r\n/**\r\n * Abort controller for the document.\r\n */\r\nlet documentController: AbortController | undefined;\r\n\r\nexport function dropOrSwap<T>(dropSwapConfig: DropSwapConfig<T> = {}) {\r\n  return (parent: HTMLElement) => {\r\n    const parentData = parents.get(parent);\r\n\r\n    if (!parentData) return;\r\n\r\n    const dropSwapParentConfig = {\r\n      ...parentData.config,\r\n      dropSwapConfig,\r\n    };\r\n\r\n    return {\r\n      setup() {\r\n        dropSwapParentConfig.handleNodeDragover =\r\n          dropSwapConfig.handleNodeDragover || handleNodeDragover;\r\n\r\n        dropSwapParentConfig.handleParentDragover =\r\n          dropSwapConfig.handleParentDragover || handleParentDragover;\r\n\r\n        dropSwapParentConfig.handleNodePointerover =\r\n          dropSwapConfig.handleNodePointerover || handleNodePointerover;\r\n\r\n        dropSwapParentConfig.handleParentPointerover =\r\n          dropSwapConfig.handleParentPointerover || handeParentPointerover;\r\n\r\n        const originalHandleend = dropSwapParentConfig.handleEnd;\r\n\r\n        dropSwapParentConfig.handleEnd = (\r\n          state: DragState<T> | SynthDragState<T>\r\n        ) => {\r\n          handleEnd(state);\r\n\r\n          originalHandleend(state);\r\n        };\r\n\r\n        parentData.on(\"dragStarted\", () => {\r\n          documentController = addEvents(document, {\r\n            dragover: rootDragover,\r\n            handleRootPointerover: rootPointerover,\r\n          });\r\n        });\r\n\r\n        parentData.on(\"dragEnded\", () => {\r\n          documentController?.abort();\r\n        });\r\n\r\n        parentData.config = dropSwapParentConfig;\r\n      },\r\n    };\r\n  };\r\n}\r\n\r\nfunction rootDragover(_e: DragEvent) {\r\n  if (!isDragState(state)) return;\r\n\r\n  removeClass(\r\n    [state.currentParent.el],\r\n    state.currentParent.data.config.dropZoneParentClass\r\n  );\r\n\r\n  state.currentParent = state.initialParent;\r\n}\r\n\r\nfunction rootPointerover(_e: CustomEvent) {\r\n  if (!isSynthDragState(state)) return;\r\n\r\n  removeClass(\r\n    [state.currentParent.el],\r\n    state.currentParent.data.config.synthDropZoneParentClass\r\n  );\r\n\r\n  state.currentParent = state.initialParent;\r\n}\r\n\r\nfunction updateDraggedOverNodes<T>(\r\n  data: PointeroverNodeEvent<T> | NodeDragEventData<T>,\r\n  state: DragState<T> | SynthDragState<T>\r\n) {\r\n  const targetData =\r\n    \"detail\" in data ? data.detail.targetData : data.targetData;\r\n\r\n  const config = targetData.parent.data.config;\r\n\r\n  const dropZoneClass = isSynthDragState(state)\r\n    ? config.synthDropZoneClass\r\n    : config.dropZoneClass;\r\n\r\n  removeClass(\r\n    dropSwapState.draggedOverNodes.map((node) => node.el),\r\n    dropZoneClass\r\n  );\r\n\r\n  const enabledNodes = targetData.parent.data.enabledNodes;\r\n\r\n  if (!enabledNodes) return;\r\n\r\n  dropSwapState.draggedOverNodes = enabledNodes.slice(\r\n    targetData.node.data.index,\r\n    targetData.node.data.index + state.draggedNodes.length\r\n  );\r\n\r\n  addNodeClass(\r\n    dropSwapState.draggedOverNodes.map((node) => node.el),\r\n    dropZoneClass,\r\n    true\r\n  );\r\n\r\n  state.currentTargetValue = targetData.node.data.value;\r\n\r\n  state.currentParent = targetData.parent;\r\n\r\n  addClass(\r\n    state.currentParent.el,\r\n    isSynthDragState(state)\r\n      ? config.synthDropZoneParentClass\r\n      : config.dropZoneParentClass,\r\n    state.currentParent.data,\r\n    true\r\n  );\r\n}\r\n\r\nfunction handleNodeDragover<T>(\r\n  data: NodeDragEventData<T>,\r\n  state: DragState<T>\r\n) {\r\n  data.e.preventDefault();\r\n\r\n  data.e.stopPropagation();\r\n\r\n  updateDraggedOverNodes(data, state);\r\n}\r\n\r\nexport function handleParentDragover<T>(\r\n  data: ParentDragEventData<T>,\r\n  state: DragState<T>\r\n) {\r\n  data.e.preventDefault();\r\n\r\n  data.e.stopPropagation();\r\n\r\n  const currentConfig = state.currentParent.data.config;\r\n\r\n  removeClass(\r\n    dropSwapState.draggedOverNodes.map((node) => node.el),\r\n    currentConfig.dropZoneClass\r\n  );\r\n\r\n  removeClass([state.currentParent.el], currentConfig.dropZoneParentClass);\r\n\r\n  const config = data.targetData.parent.data.config;\r\n\r\n  addClass(\r\n    data.targetData.parent.el,\r\n    config.dropZoneParentClass,\r\n    data.targetData.parent.data,\r\n    true\r\n  );\r\n\r\n  dropSwapState.draggedOverNodes = [];\r\n\r\n  state.currentParent = data.targetData.parent;\r\n}\r\n\r\nexport function handeParentPointerover<T>(data: PointeroverParentEvent<T>) {\r\n  const currentConfig = data.detail.state.currentParent.data.config;\r\n\r\n  removeClass(\r\n    dropSwapState.draggedOverNodes.map((node) => node.el),\r\n    currentConfig.synthDropZoneClass\r\n  );\r\n\r\n  removeClass(\r\n    [data.detail.state.currentParent.el],\r\n    currentConfig.synthDropZoneParentClass\r\n  );\r\n\r\n  const config = data.detail.targetData.parent.data.config;\r\n\r\n  addClass(\r\n    data.detail.targetData.parent.el,\r\n    config.synthDropZoneParentClass,\r\n    data.detail.targetData.parent.data,\r\n    true\r\n  );\r\n\r\n  dropSwapState.draggedOverNodes = [];\r\n\r\n  data.detail.state.currentParent = data.detail.targetData.parent;\r\n}\r\n\r\nfunction handleNodePointerover<T>(data: PointeroverNodeEvent<T>) {\r\n  if (!isSynthDragState(data.detail.state)) return;\r\n\r\n  updateDraggedOverNodes(data, data.detail.state);\r\n}\r\n\r\nfunction swapElements<T>(\r\n  arr1: T[],\r\n  arr2: T[] | null,\r\n  index1: number | number[],\r\n  index2: number\r\n): T[] | [T[], T[]] {\r\n  const indices1 = Array.isArray(index1) ? index1 : [index1];\r\n\r\n  if (arr2 === null) {\r\n    const elementsFromArr1 = indices1.map((i) => arr1[i]);\r\n\r\n    const elementFromArr2 = arr1[index2];\r\n\r\n    arr1.splice(index2, 1, ...elementsFromArr1);\r\n\r\n    indices1.forEach((i, idx) => {\r\n      arr1[i] = idx === 0 ? elementFromArr2 : (undefined as unknown as T);\r\n    });\r\n\r\n    return arr1.filter((el) => el !== undefined);\r\n  } else {\r\n    const elementsFromArr1 = indices1.map((i) => arr1[i]);\r\n\r\n    const elementFromArr2 = arr2[index2];\r\n\r\n    arr2.splice(index2, 1, ...elementsFromArr1);\r\n\r\n    indices1.forEach((i, idx) => {\r\n      arr1[i] = idx === 0 ? elementFromArr2 : (undefined as unknown as T);\r\n    });\r\n\r\n    return [arr1.filter((el) => el !== undefined), arr2];\r\n  }\r\n}\r\n\r\nfunction handleEnd<T>(state: DragState<T> | SynthDragState<T>) {\r\n  const isSynth = isSynthDragState(state);\r\n\r\n  removeClass(\r\n    [state.currentParent.el],\r\n    isSynth\r\n      ? state.currentParent.data.config.synthDropZoneParentClass\r\n      : state.currentParent.data.config.dropZoneParentClass\r\n  );\r\n\r\n  removeClass(\r\n    dropSwapState.draggedOverNodes.map((node) => node.el),\r\n    isSynth\r\n      ? state.currentParent.data.config.synthDropZoneClass\r\n      : state.currentParent.data.config.dropZoneClass\r\n  );\r\n\r\n  const values = parentValues(state.currentParent.el, state.currentParent.data);\r\n\r\n  const draggedValues = state.draggedNodes.map((node) => node.data.value);\r\n\r\n  const newValues = values.filter((x) => !draggedValues.includes(x));\r\n\r\n  const targetIndex = dropSwapState.draggedOverNodes[0]?.data.index;\r\n\r\n  const draggedIndex = state.draggedNodes[0].data.index;\r\n\r\n  const initialParentValues = parentValues(\r\n    state.initialParent.el,\r\n    state.initialParent.data\r\n  );\r\n\r\n  if (targetIndex === undefined) {\r\n    if (state.initialParent.el === state.currentParent.el) return;\r\n\r\n    const newInitialValues = initialParentValues.filter(\r\n      (x) => !draggedValues.includes(x)\r\n    );\r\n\r\n    setParentValues(\r\n      state.initialParent.el,\r\n      state.initialParent.data,\r\n      newInitialValues\r\n    );\r\n\r\n    setParentValues(\r\n      state.currentParent.el,\r\n      state.currentParent.data,\r\n      values.concat(draggedValues)\r\n    );\r\n\r\n    return;\r\n  }\r\n\r\n  let swap = false;\r\n\r\n  const shouldSwap = state.initialParent.data.config.dropSwapConfig?.shouldSwap;\r\n\r\n  if (shouldSwap)\r\n    swap = shouldSwap({\r\n      sourceParent: state.initialParent,\r\n      targetParent: state.currentParent,\r\n      draggedNodes: state.draggedNodes,\r\n      targetNodes: dropSwapState.draggedOverNodes as NodeRecord<T>[],\r\n      state,\r\n    });\r\n\r\n  if (state.initialParent.el === state.currentParent.el) {\r\n    newValues.splice(targetIndex, 0, ...draggedValues);\r\n\r\n    setParentValues(\r\n      state.currentParent.el,\r\n      state.currentParent.data,\r\n      swap ? swapElements(values, null, draggedIndex, targetIndex) : newValues\r\n    );\r\n\r\n    if (state.initialParent.data.config.onSort) {\r\n      state.initialParent.data.config.onSort({\r\n        parent: {\r\n          el: state.initialParent.el,\r\n          data: state.initialParent.data,\r\n        } as ParentRecord<unknown>,\r\n        previousValues: [...initialParentValues],\r\n        previousNodes: [...state.initialParent.data.enabledNodes],\r\n        nodes: [...state.initialParent.data.enabledNodes],\r\n        values: [...newValues],\r\n        draggedNodes: state.draggedNodes,\r\n        previousPosition: draggedIndex,\r\n        position: targetIndex,\r\n        targetNodes: dropSwapState.draggedOverNodes as NodeRecord<T>[],\r\n        state: state as BaseDragState<unknown>,\r\n      });\r\n    }\r\n  } else {\r\n    if (swap) {\r\n      const res = swapElements(\r\n        initialParentValues,\r\n        newValues,\r\n        state.initialIndex,\r\n        targetIndex\r\n      );\r\n\r\n      setParentValues(\r\n        state.initialParent.el,\r\n        state.initialParent.data,\r\n        res[0] as T[]\r\n      );\r\n\r\n      setParentValues(\r\n        state.currentParent.el,\r\n        state.currentParent.data,\r\n        res[1] as T[]\r\n      );\r\n    } else {\r\n      const newInitialValues = initialParentValues.filter(\r\n        (x) => !draggedValues.includes(x)\r\n      );\r\n\r\n      setParentValues(\r\n        state.initialParent.el,\r\n        state.initialParent.data,\r\n        newInitialValues\r\n      );\r\n\r\n      newValues.splice(targetIndex, 0, ...draggedValues);\r\n\r\n      setParentValues(\r\n        state.currentParent.el,\r\n        state.currentParent.data,\r\n        newValues\r\n      );\r\n    }\r\n  }\r\n\r\n  if (state.currentParent.data.config.onTransfer) {\r\n    state.currentParent.data.config.onTransfer({\r\n      sourceParent: state.currentParent,\r\n      targetParent: state.initialParent,\r\n      initialParent: state.initialParent,\r\n      draggedNodes: state.draggedNodes,\r\n      targetIndex,\r\n      state,\r\n      targetNodes: dropSwapState.draggedOverNodes as NodeRecord<T>[],\r\n    });\r\n  }\r\n\r\n  if (state.initialParent.data.config.onTransfer) {\r\n    state.initialParent.data.config.onTransfer({\r\n      sourceParent: state.initialParent,\r\n      targetParent: state.currentParent,\r\n      initialParent: state.initialParent,\r\n      draggedNodes: state.draggedNodes,\r\n      targetIndex,\r\n      state,\r\n      targetNodes: dropSwapState.draggedOverNodes as NodeRecord<T>[],\r\n    });\r\n  }\r\n}\r\n"],"mappings":"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","names":["handleEnd","handleNodeDragover","handleNodePointerover","handleParentDragover","handleParentPointerover","emit","on","state","insertState","state","draggedParentValues","documentController","handleNodeDragover","handleParentDragover","state","handleEnd","documentController","baseDragState","dragStateProps","handleEnd","nodes","emit","on","handleNodeDragover","handleParentDragover","handleNodePointerover","handleParentPointerover","draggedNodes","state","parent","x","scrollTimeout","className"]}